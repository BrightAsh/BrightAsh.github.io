--- 
title: "AI 에이전트 이해하기 | Understanding AI Agents" 
date: 2025-04-07 10:00:00 +0900
achieved: 2025-04-10 11:00:00 +0900
math: true
categories: [LLM, AI Agents, Understanding AI Agents]
tags: [LLM, AI Agents, Understanding AI Agents]
---
---------- 	
> 내가 볼려고 작성한 LLM 공부 (참고 서적: 랭체인 & 랭그래프로 AI 에이전트 개발하기). 
{: .prompt-info } 


# 🤖 AI 에이전트의 개념

AI 기술은 이제 단순히 질문에 응답하는 수준을 넘어,  
**사람의 개입 없이 스스로 계획하고 실행하는 ‘AI 에이전트’** 로 진화하고 있습니다.  
AI 에이전트는 특정 목표를 달성하기 위해 여러 단계를 거치며, 다양한 기술과 협업합니다.

## 🚀 1. AI 에이전트란?

### ✅ 1.1 정의와 역할

AI 에이전트는 **사람의 명령 없이도 스스로 작업을 수행하고 의사결정을 내리는 지능형 프로그램**입니다.  
단순한 자동화 도구가 아니라, **작업 이해 → 계획 수립 → 실행 → 결과 평가 → 필요시 재계획**을 반복합니다.

> **에이전트(Agent)란?**  
> 환경으로부터 입력을 받아, 그에 따라 행동을 수행하는 시스템을 말합니다.  
> AI 에이전트는 목표 지향적으로 스스로 사고하고, 학습하며, 실행할 수 있습니다.

| 핵심 개념 | 설명 |
|-----------|------|
| 자동화 | 사람이 직접 개입하지 않아도 작업이 수행됨 |
| 효율성 | 반복 작업 제거, 빠른 처리 |
| 자율성 | 에이전트가 스스로 판단하여 작업 흐름 조절 |

### ✅ 1.2 주요 사례

| 작업 종류 | 설명 | 예시 |
|-----------|------|------|
| 웹 검색 자동화 | 인터넷에서 정보 수집 후 요약 | 제품 비교, 뉴스 요약 |
| 데이터 분석 | 구조화된 데이터를 요약/해석 | 보고서 자동 생성 |
| 자연어 처리 | 사용자 명령 이해 및 응답 생성 | 이메일, 요약, 번역 등 |
| 코드 생성/수정 | 코드 작성 및 수정 반복 | 버그 수정, 리팩토링 |
| 다단계 작업 수행 | 작업을 여러 단계로 나눠 순차 실행 | 조사 → 요약 → 발송 |

## 🚀 2. LLM, RAG, AI 에이전트 비교

### ✅ 2.1 세 가지 기술 개념 비교

| 항목 | LLM | RAG | AI 에이전트 |
|------|-----|-----|-------------|
| 역할 | 문장 생성, 질문 응답 | 실시간 정보 검색 및 요약 | 목표 기반 작업 수행 |
| 주요 기능 | 텍스트 생성 | 외부 검색 결과 통합 | 작업 계획, 분할, 실행 |
| 핵심 역할 | 언어 처리 | 최신 정보 제공 | 종합적인 문제 해결 |
| 구성 요소 | 파라미터, 토큰 처리 | LLM + 검색 시스템 | LLM + RAG + 워크플로우 |
| 정보 출처 | 학습 데이터(고정) | 실시간 외부 정보 | 외부 정보 + 내부 처리 |
| 실시간 정보 | ❌ (불가능) | ✅ | ✅ |
| 목표 지향성 | ❌ | ❌ | 명확한 목표 수행 가능 |
| 대표 예시 | ChatGPT | Bing AI, Perplexity | AutoGPT, Devin, OpenAgent |


### ✅ 2.2 사례 시나리오: 3가지 기술의 차이

> **질문**  
> “2025년 미국 대통령이 누구인지, 그의 주요 정책 3가지와 시장 반응까지 조사해줘.”

**LLM (예: GPT-3.5)**  
- 2024년 이전의 학습 데이터만 보유 → 답변 정확도 낮음  
- 하나의 문장 생성으로 끝남 (추론이나 외부 조사 불가)

**RAG (Retrieval-Augmented Generation)**  
- 웹 검색으로 최신 대통령 정보 + 정책 정보 제공 가능  
- 하지만 전체 과정을 한 번에 처리 (작업 분할 불가)

**AI 에이전트**  
- 질문을 하위 작업으로 나눔 → 계획 수립 → 각 작업 실행 → 통합 응답 생성  
- LLM과 RAG를 단계별로 조합해 복잡한 요청 해결

---

### ✅ 2.3 단계별 작업 예시 (AI 에이전트)

| 단계 | 작업 내용 | 담당 구성 요소 |
|------|-----------|----------------|
| 1 | 사용자 명령 수신 | 에이전트 |
| 2 | 명령을 분석하고 작업 계획 수립 | 에이전트 (LLM 활용) |
| 3 | “2025년 미국 대통령 찾기” | RAG |
| 4 | “대통령의 주요 정책 3가지 조사” | RAG |
| 5 | “시장 반응 분석을 위한 뉴스 검색” | RAG |
| 6 | 수집된 정보를 종합해 요약 | LLM |
| 7 | 정보가 부족하면 계획 재조정 | 에이전트 |
| 8 | 최종 결과물 생성 | LLM |

> **핵심 포인트**  
> AI 에이전트는 단일 응답이 아닌, **일련의 작업을 자동으로 나눠서 처리**합니다.  
> 이렇게 함으로써 사람처럼 ‘조사 → 판단 → 요약’의 복합적 사고 과정을 재현할 수 있습니다.


<br>
<br>
<br>

---
# 🤖 AI 에이전트 구성 및 동작 방식

AI 에이전트는 단순히 지시를 따르는 도구가 아닙니다.  
사용자의 목표를 이해하고, 이를 달성하기 위한 일련의 과정을 스스로 **계획, 실행, 평가, 재계획**하는 **지능형 자율 시스템**입니다.  
이 장에서는 에이전트의 구성 요소와 내부 동작 원리를 구체적으로 살펴봅니다.

## 🚀 1. AI 에이전트 구성 요소

AI 에이전트는 다음과 같은 주요 구성 요소로 이루어져 있습니다:

- LLM (언어 모델)
- 계획 모듈 (Planning)
- 실행 모듈 (Action)
- 메모리 (Memory)
- 프로필 (Profile)

이들 요소는 상호 연결되어 전체 동작을 수행합니다.


### ✅ 1.1 LLM (Large Language Model)

> **LLM은 에이전트의 ‘뇌’ 역할을 합니다.**  
> 사용자 명령을 이해하고 자연어로 작업을 생성하며, 결과를 요약하거나 응답을 생성하는 핵심 엔진입니다.

LLM이 수행하는 주요 기능:

- **자연어 처리**: 사용자의 지시 해석
- **텍스트 생성**: 질문 응답, 이메일 작성, 요약 등
- **맥락 이해**: 대화 흐름과 상황 파악
- **의사 결정 지원**: 어떤 작업을 먼저 수행할지 판단

### ✅ 1.2 계획 (Planning)

> **계획이란 복잡한 문제를 관리 가능한 하위 작업으로 나누는 과정입니다.**  
> 작업 간 우선순위를 정하고, 필요시 계획을 유연하게 수정합니다.

주요 요소:

- **목표 인식**: 사용자의 요청을 최종 목표로 설정
- **하위 작업 생성**: 목표를 이루기 위한 세부 작업 나열
- **우선순위 설정**: 어떤 작업부터 수행할지 결정
- **재계획 기능**: 실패하거나 변경된 상황에 유연하게 대처

### ✅ 1.3 실행 (Action)

> **계획된 작업을 실제로 실행하는 모듈**입니다.  
> 다양한 API나 외부 도구와 연동해 작업을 확장합니다.

예: 웹 검색, 코드 실행, 데이터베이스 질의 등

#### 대표 도구/API 활용 예시

- **웹 검색 API** (Tavily, Bing, Serper 등)
  1. 사용자 질의 입력
  2. 관련 검색 결과 수집
  3. 분석 후 요약 결과 생성

- **데이터베이스 쿼리**
  1. LLM이 쿼리 생성 (`SELECT ...`)
  2. DB와 연결하여 실행
  3. 결과를 받아 분석 및 응답

> 실행 모듈이 없다면 에이전트는 단순 생성기(LLM) 이상이 될 수 없습니다.


### ✅ 1.4 프로필 (Profile)

> **에이전트의 ‘성격과 역할’을 정의하는 모듈**입니다.  
> 어떤 어조로 말할지, 어떤 윤리를 지킬지, 어떤 정보를 활용할지 등이 설정됩니다.

| 구성 요소 | 설명 | 예시 |
|-----------|------|------|
| 역할 및 직책 | 어떤 직무를 수행할지 | 고객지원 상담원, 의료 보조 |
| 어조 및 스타일 | 말투와 커뮤니케이션 방식 | 정중함, 친근함, 공식적 표현 |
| 윤리 및 제약 | 하지 말아야 할 규칙 | 개인 정보 요구 X, 금융 조언 제한 |
| 전문 지식 | 어느 분야의 지식 적용 | 법률, 의학, 교육 등 |
| 작업 처리 방식 | 결과 요약, 순차 처리 등 | 요약 우선, 다단계 처리 |
| 언어 지원 | 다국어 응답 여부 | 한국어, 영어, 일본어 등

> 고객 서비스용 에이전트는 특히 **친절하고 공손한 어조**, **개인 정보 보호**, **오류 최소화** 등의 프로필 세팅이 중요합니다.

---

### ✅ 1.5 메모리 (Memory)

> **대화의 흐름과 과거 정보를 기억해, 개인화된 응답을 가능하게 합니다.**

| 유형 | 설명 | 예시 |
|------|------|------|
| 단기 메모리 (STM) | 현재 대화 내역 | 직전 대화의 질문 및 응답 |
| 장기 메모리 (LTM) | 사용자 프로필, 누적 대화 | 사용자 이름, 선호 주제 기억 |

> **LangChain, LangGraph, AutoGPT** 등 주요 프레임워크는 메모리 관리 기능을 기본 제공합니다.


### ✅ 1.6 구성요소 간 연계

AI 에이전트는 다음과 같은 흐름으로 작동합니다:

`LLM ⇄ Planning ⇄ Action ⇄ Memory ⇄ Profile`

## 🚀 2. AI 에이전트 동작 방식

AI 에이전트는 사용자의 명령을 받아, **다단계로 작업을 수행**합니다.

`사용자 입력 → 계획 수립 → 실행 → 결과 평가 → (필요 시) 재계획 → 응답 생성 → 종료`


### ✅ 2.1 사용자 명령 → “목표 설정”

- 사용자의 지시를 에이전트가 받아들임
- 목표를 인식하고 Planning 모듈로 전달

### ✅ 2.2 계획 수립 (Planning)

- 목표를 여러 개의 하위 작업으로 분리
- 작업 순서 및 우선순위 결정
- 필요 시 메모리 기반 사용자 정보 반영

### ✅ 2.3 작업 실행 (Action)

- 외부 도구와 상호작용
- 웹 검색, API 호출, DB 질의, 파일 생성 등 실행

### ✅ 2.4 작업 결과 평가

- 결과가 목표와 맞는지 판단
- 필요 시 LLM이 해석하고 다음 단계 판단

### ✅ 2.5 재계획 (선택적)

- 작업 실패/정보 부족 시 새 계획 수립
- 이전 흐름 기반으로 계획 조정

### ✅ 2.6 최종 응답 생성

- 전체 작업 결과를 기반으로 LLM이 응답 생성
- 프로필과 메모리 반영해 맥락 있는 답변 제공

### ✅ 2.7 종료

- 대화 종료, 최종 기록 저장, 후속 작업 준비


## 🚀 3. 에이전트 유형

AI 에이전트는 거의 독립적으로 동작하며,  
환경을 관찰하고 정보를 해석한 뒤, 이에 기반해 의사결정을 내리고 행동합니다.  
비즈니스 과제에 따라 가장 적합한 유형을 선택해 설계하는 것이 중요합니다.

> 하나의 에이전트가 단일 유형으로만 구성되는 것은 아닙니다.  
> 실제 시스템은 여러 유형을 조합해 구성되는 경우가 많습니다.

---

### ✅ 3.1 단순 반응 에이전트 (Simple Reflex Agents)

- **사전에 정의된 규칙**에 따라 즉각 반응
- 과거의 경험이나 내부 상태를 고려하지 않음
- 단순한 상황에서는 빠르고 안정적인 응답이 가능

> **`사전에 정의된 규칙`이란?**  
> “만약 A 상황이면 B 행동을 한다” 같은 조건-행동 매핑으로,  
> 복잡한 연산 없이 단순 조건에만 반응합니다.

> **예시**:  
> - 바닥이 더러울 경우, 자동으로 청소 모드로 전환하는 로봇 청소기

| 장점 항목 | 설명 |
|-----------|------|
| 설계 및 구현 용이 | 로직이 단순하여 빠르게 만들 수 있음 |
| 실시간 반응 | 즉시 반응 가능 |
| 높은 신뢰성 | 예측 가능한 동작 패턴 |

| 단점 항목 | 설명 |
|-----------|------|
| 상태 저장 불가 | 이전 상황을 기억하지 못함 |
| 오류에 민감 | 복잡한 환경에선 비효율적 |

---

### ✅ 3.2 모델 기반 반응 에이전트 (Model-based Reflex Agents)

- **환경에 대한 내부 모델**을 갖추고 판단
- 조건-행동 규칙을 사용하지만, 내부 상태를 추론에 활용

> **예시**:  
> - 청소 이력을 기억하고, 아직 청소하지 않은 구역을 우선 처리

| 장점 항목 | 설명 |
|-----------|------|
| 효율적인 의사결정 | 과거 정보 활용으로 낭비 감소 |
| 환경 변화 적응 | 새로운 상황에도 일정 부분 대응 가능 |

| 단점 항목 | 설명 |
|-----------|------|
| 유지 비용 증가 | 상태 저장 및 추론 구조 필요 |
| 복잡한 환경 반영 어려움 | 모델 설계가 어려울 수 있음 |

---

### ✅ 3.3 목표 기반 에이전트 (Goal-based Agents)

- **명확한 목표**를 가지고 목표 달성을 위한 경로 탐색 수행
- 목표 중심으로 상황을 분석하고, 가능한 행동 중 선택

> **`경로탐색 알고리즘(Pathfinding Algorithm)`이란?**  
> 시작 지점에서 목표 지점까지 가장 빠르거나 효율적인 경로를 계산하는 알고리즘입니다.  
> 예: A* 알고리즘, 다익스트라(Dijkstra) 알고리즘

> **예시**:  
>- 로봇이 장애물을 피해 목적지까지 가장 빠른 길로 이동

| 장점 항목 | 설명 |
|-----------|------|
| 목표 달성 효율적 | 불필요한 행동 최소화 |
| 구현 이해 용이 | 로직이 직관적 |
| 다른 AI와 결합 가능 | 학습 기반 기술과 통합 가능 |

| 단점 항목 | 설명 |
|-----------|------|
| 목표 편중 | 특정 목표 외에는 무능 |
| 도메인 지식 필요 | 목표 정의 및 설계에 지식 필요 |

---

### ✅ 3.4 유틸리티 기반 에이전트 (Utility-based Agents)

- 가능한 모든 행동을 평가하고 **가장 유리한 선택**을 수행
- 보상, 효용(utility), 리스크 등을 고려해 판단

> **예시**:  
> 주식 자동매매 시스템, 자율주행 차량의 경로 결정

| 장점 항목 | 설명 |
|-----------|------|
| 복잡한 문제 처리 | 다중 선택지에서 최선 선택 |
| 일관된 의사결정 | 기준이 명확함 |
| 불확실성에 강함 | 다양한 시나리오 예측 가능 |

| 단점 항목 | 설명 |
|-----------|------|
| 계산 비용 큼 | 유틸리티 계산에 시간/자원 소모 |
| 해석 어려움 | 왜 그 판단을 내렸는지 이해 어려움 |

---

### ✅ 3.5 학습 에이전트 (Learning Agents)

- **과거 피드백을 바탕으로 행동 전략을 개선**
- 강화학습, 지도학습 등 다양한 ML 기법 사용

> **예시**:  
> 자율주행 차량이 운전 데이터를 통해 주행 전략을 개선

| 장점 항목 | 설명 |
|-----------|------|
| 지속적 성능 향상 | 학습을 통해 적응 |
| 문제 해결 확장 | 처음 몰랐던 문제도 나중에 해결 가능 |

| 단점 항목 | 설명 |
|-----------|------|
| 오판 위험 | 잘못된 데이터를 학습할 수 있음 |
| 높은 비용 | 데이터 수집, 학습 자원 필요 |
| 복잡성 증가 | 모델 관리 및 검증 어려움 |

---

### ✅ 3.6 계층적 에이전트 (Hierarchical Agents)

- **작업을 여러 계층으로 분리하여 수행**
- 상위 목표 → 중간 목표 → 하위 작업으로 세분화

> **예시**:  
> 스마트 공장에서 생산 계획 → 라인 제어 → 개별 설비 제어로 나눠 처리

| 장점 항목 | 설명 |
|-----------|------|
| 자원 효율성 ↑ | 병렬 작업 및 분할 가능 |
| 복잡도 분산 | 관리와 유지 용이 |
| 명확한 역할 분담 | 각 계층이 명확한 역할 수행 |

| 단점 항목 | 설명 |
|-----------|------|
| 구조 설계 어려움 | 계층 설계 복잡성 존재 |
| 적응력 제한 | 예상 외 상황에 유연성 낮음 |
| 병렬 처리 어려움 | 병렬화가 어려운 구조일 수도 있음 |


<br>
<br>
<br>

---
# 🤖 AI 에이전트 디자인 패턴

`AI 에이전트 디자인 패턴`은 LLM을 활용해 AI가 **스스로 사고하고, 계획하고, 실행할 수 있도록 설계된 구조적 접근 방식**입니다.  
복잡한 문제 해결, 고품질 응답 생성, 효율적인 자동화를 위해 다양한 패턴들이 사용됩니다.

## 🚀 1. 반응 패턴 (Reflection Pattern)

### ✅ 1.1 정의

- AI가 **자기 응답을 평가하고 반복적으로 개선**하는 패턴  
- 초기 응답 → 자기 평가 → 수정 반복 → 기준 도달 시 종료

> **Reflection이란?**  
> AI가 생성한 결과를 **자신이 다시 읽고 분석하며 개선**하는 과정을 의미합니다.  
> 사람이 글을 쓰고, 다시 읽으며 고치는 것과 유사합니다.

### ✅ 1.2 처리 과정

1. **초기 응답 생성**  
   - AI가 사용자 질문에 대한 초안 생성  
2. **자기 평가 (Self-assessment)**  
   - 생성된 답변의 오류, 모호한 표현, 부족한 점 등을 자체적으로 분석  
3. **수정 및 개선**  
   - 자기 평가 결과를 바탕으로 내용을 수정 및 보완  
4. **종료 조건**  
   - 품질 기준을 만족하거나 반복 횟수 초과 시 종료

``` plaintext
    → 초기 응답 생성 -
    |                |
 수정된 답변         ↓
     |          자기 평가
      ←---------- 
```

### ✅ 1.3 장점

| 장점 | 설명 |
|------|------|
| 품질 향상 | 단순 1회 출력이 아닌 반복 개선으로 응답 품질 향상 |
| 정확성 개선 | AI가 스스로 오류를 찾아 수정 |
| 복잡한 문제 해결 | 애매하거나 모호한 표현을 명확하게 개선 |
| 개발자 개입 감소 | 사람이 직접 피드백하지 않아도 AI가 자율 개선 |


### ✅ 1.4 단점

| 단점 | 설명 |
|------|------|
| 계산 비용 증가 | 반복 실행에 따른 처리 시간 및 비용 증가 |
| 복잡성 증가 | 간단한 응답에도 반복 평가 구조 필요 |
| 무한 반복 위험 | 종료 조건 없으면 무한 루프 |
| 종료 조건 필요 | 품질 기준, 반복 횟수 제한 등 명확한 조건 설정 필요 |

### ✅ 1.5 활용 예시

- **문서 생성 AI**: 초안 → 자기 피드백 → 수정 → 최종 버전  
- **교육 AI 플랫폼**: 학습 콘텐츠 자동 평가 및 개선  

## 🚀 2. 계획 패턴 (Planning Pattern)

### ✅ 2.1 정의

- 문제 해결을 위한 **계획 수립 → 작업 분해 → 실행 → 반복 개선**을 수행  
- 반응 패턴의 확장으로, **명시적인 작업 분할과 실행 흐름 포함**

### ✅ 2.2 처리 단계

1. **계획 수립 (Planning)**  
   - 문제 해결을 위한 전체 전략 설계  
2. **작업 분해 (Generate Tasks)**  
   - 계획을 구체적인 단위 작업으로 나눔  

> 예시 질문: “프롬프트 엔지니어링이란?”  
> 1단계: 웹에서 프롬프트 엔지니어링 검색  
> 2단계: 검색 결과 요약  
> 3단계: 사용자에게 요약 제공  

3. **단일 작업 에이전트 실행**  
   - 각각의 작업을 하나의 에이전트가 담당  
4. **재계획 (Replan)**  
   - 결과가 불충분하거나 실패 시 계획 재수립  
5. **반복 수행 (Iterate)**  
   - 필요한 만큼 작업 반복 → 최적 결과 도출

```plaintext
프롬프트 → 계획 수립
              ↓
         작업 생성
              ↓
     단일 작업 에이전트 실행
              ↓
           재계획 여부 판단
```

## 🚀 3. 도구 사용 패턴 (Tool Use Pattern)

### ✅ 3.1 정의

- LLM이 외부 도구(API, DB, 검색 등)를 사용하여 **실시간 데이터와 최신 정보**를 활용  
- **LLM 자체에 의존하지 않고, 도구와 협력**하여 처리 정확도와 범위를 확장

> 기존 LLM은 사전 학습 데이터만 사용 → 최신 정보 반영 불가  
> 도구 사용 패턴은 이 한계를 극복하는 핵심 전략

```plaintext
프롬프트 → LLM → 도구 호출 → 실시간 데이터 → 응답 생성
```

## 🚀 4. 멀티에이전트 패턴 (Multi-Agent Pattern)

### ✅ 4.1 정의

- 하나의 복잡한 작업을 여러 개의 전문 에이전트에게 **분산 처리**시키는 방식  
- 각 에이전트는 자신이 맡은 역할에 특화되어 있음  
- **협업 기반 자동화 시스템** 구성 가능

> 예시  
> - 검색 에이전트 → 정보 수집  
> - 생성 에이전트 → 문서 생성  
> - 검토 에이전트 → 문법 검사  
> - 요약 에이전트 → 콘텐츠 요약  

``` plaintext
프롬프트 → 에이전트1 → 에이전트2 → 에이전트3 → 에이전트4 → (반복) → 최종 응답
```

### ✅ 4.2 장점

| 장점 | 설명 |
|------|------|
| 병렬 처리 가능 | 여러 작업을 동시에 진행해 속도 향상 |
| 확장성 우수 | 새 에이전트 추가만으로 시스템 확장 가능 |
| 유연성 확보 | 실패한 작업은 재계획하거나 다른 에이전트에게 할당 |
| 자율적 협업 | 에이전트들이 자체적으로 목표 달성 조율 가능 |

> **복잡한 콘텐츠 제작, 제품 설계, 자동화된 리서치** 등에 적합  
> 멀티에이전트는 LLM이 지능적 시스템으로 진화하는 핵심 모델 중 하나


## 🚀 5. CoT 프롬프팅 패턴 (Chain of Thought Prompting)

### ✅ 5.1 정의

- AI가 **즉시 응답을 생성하는 대신, 단계별 사고 과정을 거치도록 유도**하는 기법  
- CoT를 통해 AI는 문제 해결에 필요한 논리를 하나씩 전개 → **정확한 답변 생성 가능**


### ✅ 5.2 처리 과정

1. **질문 이해**  
   - 사용자의 질문을 분석  
2. **추론 단계 생성**  
   - 사고의 흐름에 따라 단계별 논리 전개  

> 예시  
> 질문: 철수는 사과 10개를 가지고 있다가 3개를 먹고 2개를 받았습니다. 남은 사과는?  
> CoT:  
> - 철수는 원래 10개  
> - 3개를 먹었으므로 7개  
> - 2개를 받았으므로 총 9개

3. **최종 답변 생성**  
   - 추론 과정을 종합해 정답 도출  
> 정답: “철수에게 남은 사과는 9개입니다.”

```plaintext
프롬프트 → 추론(1) → 추론(2) → ... → 추론(n) → 최종 응답
```

### ✅ 5.3 활용 시점

- **수학 문제 해결**: 단계별 계산 과정 필요  
- **법률 분석**: 복잡한 논리를 나누어 처리  
- **교육 콘텐츠 생성**: 사고력을 키우는 AI 튜터에 적합

> GPT-4o, o1 같은 최신 모델들은 내부적으로 CoT 프롬프팅을 활용하여 복잡한 응답 생성에 활용하고 있습니다.


<br>
<br>
<br>

---
# 🤖 AI 에이전트 프레임워크

AI 에이전트 프레임워크는 **AI 에이전트를 생성, 관리, 실행**하기 위한 도구 및 라이브러리를 제공하는 소프트웨어 플랫폼입니다.  
이러한 프레임워크는 복잡한 작업 자동화, 협업, 멀티모달 응답 등을 가능하게 해주며,  
대표적인 프레임워크로는 AutoGen, LangChain, LangGraph, CrewAI, LlamaIndex, AutoGPT 등이 있습니다.

## 🚀 1. AutoGen

### ✅ 1.1 개요

- **멀티 에이전트 기반** AI 시스템 구축을 위한 오픈소스 프레임워크
- 여러 AI 에이전트가 **서로 대화하고 협업**하여 작업 수행
- 각 에이전트는 **고유 역할을 부여받고**, 이를 기반으로 작동

| 에이전트 역할 | 설명 |
|---------------|------|
| AssistantAgent | 사용자 요청에 따라 직접 작업을 수행하거나 응답 생성 |
| UserProxyAgent | 사용자 입력을 받아 다른 에이전트에 전달하는 중재자 역할 |

### ✅ 1.2 동작 예시

> 사용자 명령: “이 코드를 최적화해줘.”

```plaintext
1. UserProxyAgent → AssistantAgent에게 전달
2. AssistantAgent → LLM에 코드 개선 요청
3. LLM → 최적화된 코드 생성 및 설명 제공
4. AssistantAgent → UserProxyAgent → 사용자에게 결과 전달
```

AutoGen은 코드 실행, API 호출, 외부 시스템 연동 등 다양한 작업을  
멀티에이전트로 분산하여 효율적으로 수행할 수 있도록 설계되어 있습니다.


## 🚀 2. LangChain

### ✅ 2.1 개요

LangChain은 **LLM 기반 애플리케이션을 빠르게 개발**할 수 있도록 지원하는 프레임워크입니다.  
에이전트 설계, 체인 조합, 프롬프트 구성, 외부 도구 연결, 메모리 유지 등 LLM 활용 전반을 아우릅니다.

### ✅ 2.2 주요 기능

| 기능 | 설명 | 예시 |
|------|------|------|
| 프롬프트 관리 | 프롬프트 템플릿 구성 및 재사용 | 질문 유형별 템플릿 설정 |
| 체인 | 작업 단계를 연결한 구조 | 검색 → 요약 → 응답 |
| 에이전트 | 도구 사용 가능한 실행 주체 | 계산기, 브라우저 호출 |
| 도구 | API, DB, 검색 등 외부 시스템 | Web Search, Python Code 실행 |
| 메모리 | 대화 상태 저장 | 최근 질문 기반 응답 |
| 문서 호출 | 외부 문서 로딩 | PDF, txt |
| 정보 검색 | DB 및 검색엔진 연동 | 벡터 검색, SQL 쿼리 |

> LangChain은 단순 텍스트 생성에서 벗어나 **LLM 기반 자동화 작업 전체를 조율**하는 프레임워크입니다.


## 🚀 3. LangGraph

### ✅ 3.1 개요

LangGraph는 LangChain 기반의 확장 프레임워크로,  
**AI 에이전트의 상태 기반 워크플로우**를 시각적이고 유연하게 구성할 수 있도록 돕습니다.

> AI 시스템의 순환적 흐름 (계획 → 실행 → 재계획)을 **그래프(노드 + 상태 + 조건 흐름)** 형태로 구성


### ✅ 3.2 주요 구성요소

| 구성 요소 | 설명 | 예시 |
|-----------|------|------|
| 상태(State) | 현재 대화 상태 또는 처리중인 데이터 | 대화 기록, 작업 이력 |
| 노드(Node) | 개별 작업 단위 | 검색, 응답 생성 |
| 엣지(Edge) | 작업 흐름의 경로 연결 | 작업 A → 작업 B |

---

### ✅ 3.3 조건 흐름 예시

```plaintext
1. 시작 노드
2. 작업 수행 노드
3. 결과 평가 → 성공 시 다음 단계로
4. 실패 시 재계획 노드로 분기
5. 종료 노드 도달 시 작업 종료
```

> LangGraph는 LLM 기반 앱에 **루프, 조건 분기, 상태 유지**를 가능하게 해줍니다.


## 🚀 4. CrewAI

### ✅ 4.1 개요

CrewAI는 **역할 기반 멀티에이전트 팀(Crew)** 을 구성하여 협력 작업을 수행하는 프레임워크입니다.  
각 에이전트는 명확한 역할(Role)과 목표(Goal)를 가지고, 필요한 도구를 사용할 수 있습니다.


### ✅ 4.2 주요 구성요소

| 구성 요소 | 설명 |
|-----------|------|
| 에이전트 | 역할/목표/도구를 가진 개별 실행 단위 |
| 작업(Task) | 어떤 에이전트가 어떤 도구로 수행할지 정의 |
| 크루(Crew) | 에이전트와 작업의 집합 (하나의 팀) |

### ✅ 4.3 Python 예시
- 에이전트는 다음과 같이 role, goal, tools를 지정할 수 있습니다.
 - role에서 역할을 정의하고, goal에서 작업의 목표를 정의하고, tools에서 사용할 도구를 정의합니다.
```py
from crewai import Agent

writer_agent = Agent(
  role='Writer',
  goal='검색 내용을 바탕으로 보고서를 작성하세요',
  tools=['문서 편집기', '언어 교정 도구'],
  verbose=True
)
```
- agent에서 앞서 정의한 에이전트를 할당하고, tools에서 필요한 도구를 할당하고, expected_output에서 작업의 최종 기대 결과를 정의합니다.

```py
from crewai import Task

write_task = Task(
  description="검색 결과를 바탕으로 보고서를 작성하세요.",
  agent=writer_agent,
  tools=['문서 편집기'],
  expected_output='완성된 보고서'
)
```

> 크루AI는 팀 단위로 작업을 설계하고 실행할 수 있어 **유연성과 협업성**이 매우 높습니다.


## 🚀 5. LlamaIndex

### ✅ 5.1 개요

LlamaIndex는 LLM이 **외부 데이터(PDF, DB, 웹 등)에 접근할 수 있도록 도와주는 연결 프레임워크**입니다.  
에이전트가 문서 기반으로 답변을 생성할 수 있도록 지원합니다.

### ✅ 5.2 기능

| 기능 | 설명 | 예시 |
|------|------|------|
| 인덱싱 | 외부 데이터를 검색 가능하게 변환 | PDF → Vector |
| 질의 처리 | 질문에 맞는 문서 조각 반환 | “2023년 매출은?” → 재무 문서 |
| 에이전트 통합 | AI 에이전트가 직접 LlamaIndex 사용 | 문서 읽기 후 요약 생성 |


### ✅ 5.3 동작 흐름

```plaintext
1. 사용자 질문: “2023년 재무 보고서의 순이익 알려줘”
2. 에이전트 → LlamaIndex에 질의
3. LlamaIndex가 문서에서 관련 정보 검색
4. LLM이 결과 바탕으로 응답 생성
5. 사용자에게 최종 결과 전달
```

> LlamaIndex는 에이전트와 데이터 사이의 **브릿지 역할**을 수행합니다.

## 🚀 6. AutoGPT

### ✅ 6.1 개요

AutoGPT는 **자기 주도적으로 목표 설정 → 계획 → 실행 → 반복**까지 수행하는 자율형 에이전트 시스템입니다.  
한 번의 명령으로 **연속된 다중 작업을 자동 수행**합니다.

### ✅ 6.2 일반 LLM vs AutoGPT

| 항목 | 일반 LLM | AutoGPT |
|------|-----------|----------|
| 구조 | 입력 1개 → 출력 1개 | 입력 1개 → 하위 작업 생성 및 자동 실행 |
| 사용자 개입 | 매 단계마다 필요 | 거의 불필요 |
| 응용 예시 | 답변 생성 | 프로젝트 자동 수행 |

```plaintext
기본: 사용자 명령 → AI 응답 → 끝  
AutoGPT: 사용자 명령 → 계획 수립 → 하위 작업 생성 → 자동 실행 → 결과
```

### ✅ 6.3 예시

> 프롬프트: "1주일 식단 계획을 세우고 PDF로 저장해줘"

작업 흐름:
1. **목표 인식**: 식단 생성 + PDF 저장
2. **작업 생성**:
   - 다이어트 트렌드 검색
   - 식단 구성
   - PDF 파일로 변환
3. **자동 실행**:
   - 검색 에이전트 → 트렌드 수집  
   - 생성 에이전트 → 식단 구성  
   - 파일 에이전트 → PDF 저장
4. **최종 결과 전달**: 파일 경로 반환


### ✅ 6.4 한계

| 항목 | 설명 |
|------|------|
| 제어 어려움 | 정확한 흐름 제어가 어려움 |
| 보안 위험 | 자동 웹 접근 → 데이터 유출 가능 |
| 자원 소모 | 연속 작업 처리로 비용 증가 |

> AutoGPT는 흥미로운 가능성이 있는 반면, **실무 적용에는 안전성과 신뢰성 보완이 필요**합니다.
