--- 
title: "ê¹Šì´ ìš°ì„  íƒìƒ‰ | DFS" 
date: 2025-04-03 11:00:00 +0900
achieved: 2025-04-03 12:00:00 +0900
math: true
categories: [Algorithm, DFS]
tags: [Algorithm, DFS]
---
---------- 	
> ë‚´ê°€ ë³¼ë ¤ê³  ì‘ì„±í•œ ì•Œê³ ë¦¬ì¦˜ ê³µë¶€. 
{: .prompt-info } 
# ğŸ’¾ DFS (ê¹Šì´ ìš°ì„  íƒìƒ‰)

## âœ… 1. ê°œë… ì´í•´í•˜ê¸°

> **DFS(Depth-First Search)** ëŠ” ê·¸ë˜í”„(ë˜ëŠ” íŠ¸ë¦¬)ë¥¼ íƒìƒ‰í•˜ëŠ” ëŒ€í‘œì ì¸ ë°©ë²• ì¤‘ í•˜ë‚˜ë¡œ, í•œ ë°©í–¥ìœ¼ë¡œ ëê¹Œì§€ íƒìƒ‰í•˜ê³ , ë§‰íˆë©´ ë˜ëŒì•„ê°€ ë‹¤ë¥¸ ê²½ë¡œë¥¼ íƒìƒ‰í•˜ëŠ” ë°©ì‹ì´ë‹¤.

### DFSëŠ” ì–¸ì œ ì‚¬ìš©í• ê¹Œ?

| ìƒí™© | DFS ì‚¬ìš© ì´ìœ  |
|------|----------------|
| ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ë¥¼ íƒìƒ‰í•  ë•Œ | ë°±íŠ¸ë˜í‚¹ ê¸°ë°˜ ë¬¸ì œì—ì„œ í™œìš© |
| ê²½ë¡œê°€ ìˆëŠ”ì§€ ì—¬ë¶€ë¥¼ í™•ì¸í•  ë•Œ | ê¹Šì´ ìš°ì„ ìœ¼ë¡œ ë¹ ë¥´ê²Œ í™•ì¸ ê°€ëŠ¥ |
| ì¬ê·€ì ìœ¼ë¡œ êµ¬ì¡°ê°€ ë°˜ë³µë  ë•Œ | íŠ¸ë¦¬ íƒìƒ‰ ë“±ì—ì„œ ìœ ë¦¬ |

## âœ… 2. ì‘ë™ ë°©ì‹

### 2.1 íƒìƒ‰ íë¦„

> **DFSëŠ” ìŠ¤íƒ(ë˜ëŠ” ì¬ê·€ í˜¸ì¶œ ìŠ¤íƒ)ì„ ì´ìš©í•˜ì—¬ ê¹Šì´ ë°©í–¥ìœ¼ë¡œ íƒìƒ‰**í•œë‹¤. ì¦‰, í˜„ì¬ ì •ì ì—ì„œ ê°ˆ ìˆ˜ ìˆëŠ” ë‹¤ìŒ ì •ì ì„ í•˜ë‚˜ ì„ íƒí•´ ëê¹Œì§€ ê°€ë³´ê³ , ë§‰íˆë©´ ë˜ëŒì•„ì™€ì„œ ë‹¤ë¥¸ ê²½ë¡œë¥¼ ì‹œë„í•œë‹¤.

ì˜ˆì‹œ ê·¸ë˜í”„:

```
   A
  / \
 B   C
 |   |
 D   E
```

Aì—ì„œ DFSë¥¼ ì‹œì‘í•˜ë©´ â†’ `A â†’ B â†’ D â†’ C â†’ E` ìˆœìœ¼ë¡œ íƒìƒ‰í•œë‹¤.

### 2.2 ì˜ì‚¬ì½”ë“œ

```python
def dfs(node):
    visited[node] = True
    for neighbor in graph[node]:
        if not visited[neighbor]:
            dfs(neighbor)
```

> `visited` ë¦¬ìŠ¤íŠ¸ëŠ” ì´ë¯¸ ë°©ë¬¸í•œ ë…¸ë“œë¥¼ ë‹¤ì‹œ ë°©ë¬¸í•˜ì§€ ì•Šë„ë¡ í•˜ê¸° ìœ„í•œ ê¸°ë¡ ë„êµ¬ì´ë‹¤.

## âœ… 3. DFS êµ¬í˜„ (ì¬ê·€ & ìŠ¤íƒ)

### 3.1 ì¬ê·€ ë°©ì‹

```python
graph = {
    'A': ['B', 'C'],
    'B': ['D'],
    'C': ['E'],
    'D': [],
    'E': []
}
visited = set()

def dfs(node):
    if node not in visited:
        print(node, end=' ')
        visited.add(node)
        for neighbor in graph[node]:
            dfs(neighbor)

dfs('A')  # ì¶œë ¥: A B D C E
```

### 3.2 ìŠ¤íƒ ë°©ì‹ (ë°˜ë³µë¬¸)

```python
def dfs_stack(start):
    visited = set()
    stack = [start]

    while stack:
        node = stack.pop()
        if node not in visited:
            print(node, end=' ')
            visited.add(node)
            stack.extend(reversed(graph[node]))  # ìˆœì„œ ìœ ì§€

dfs_stack('A')  # ì¶œë ¥: A B D C E
```

> ì¬ê·€ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ìŠ¤íƒì„ ì‚¬ìš©í•˜ë¯€ë¡œ ë‘ ë°©ì‹ì€ ê°™ì€ êµ¬ì¡°ë¥¼ ê°€ì§„ë‹¤.

## âœ… 4. ì‹¤ì „ ì˜ˆì œ - ë°±ì¤€ 1260ë²ˆ: DFSì™€ BFS

### ë¬¸ì œ ìš”ì•½

- ì •ì  Nê°œ, ê°„ì„  Mê°œ
- ì£¼ì–´ì§„ ì‹œì‘ì ë¶€í„° DFS/BFS ìˆ˜í–‰ ê²°ê³¼ ì¶œë ¥

### ì…ë ¥ ì˜ˆì‹œ

```
4 5 1
1 2
1 3
1 4
2 4
3 4
```

### DFS í’€ì´

```python
n, m, start = map(int, input().split())
graph = {i: [] for i in range(1, n+1)}
for _ in range(m):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

for node in graph:
    graph[node].sort()  # ì˜¤ë¦„ì°¨ìˆœ ë°©ë¬¸

visited = set()
def dfs(v):
    print(v, end=' ')
    visited.add(v)
    for neighbor in graph[v]:
        if neighbor not in visited:
            dfs(neighbor)

dfs(start)
```

## âœ… 5. DFSë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ ê¸°ë²•

### 5.1 ë°±íŠ¸ë˜í‚¹ (Backtracking)

> **ë°±íŠ¸ë˜í‚¹ì€ DFSë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•˜ì—¬ ì¡°ê±´ì„ ë§Œì¡±í•˜ì§€ ì•Šìœ¼ë©´ íƒìƒ‰ì„ ì¤‘ë‹¨í•˜ê³  ë˜ëŒì•„ê°€ëŠ”(Backtrack) ë°©ì‹ì˜ ì•Œê³ ë¦¬ì¦˜ì´ë‹¤.** ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ë¥¼ íƒìƒ‰í•˜ì§€ë§Œ, ê°€ì§€ì¹˜ê¸°(pruning)ë¥¼ í†µí•´ ë¹„íš¨ìœ¨ì ì¸ ê²½ë¡œëŠ” ë¹¨ë¦¬ í¬ê¸°í•œë‹¤.

#### ë°±íŠ¸ë˜í‚¹ êµ¬ì¡° ì˜ˆì‹œ

```python
def backtrack(path):
    if len(path) == ëª©í‘œ:
        print(path)
        return

    for ì„ íƒ in í›„ë³´ë“¤:
        if ì¡°ê±´ì— ë§ì§€ ì•Šìœ¼ë©´ continue
        path.append(ì„ íƒ)
        backtrack(path)
        path.pop()  # ìƒíƒœ ë³µêµ¬
```

#### ëŒ€í‘œ ë¬¸ì œ ì˜ˆì‹œ

| ë¬¸ì œ | ì„¤ëª… |
|------|------|
| N-Queen | ê°™ì€ í–‰/ì—´/ëŒ€ê°ì„ ì— ë§ì´ ê²¹ì¹˜ì§€ ì•Šë„ë¡ ë°°ì¹˜ |
| ìŠ¤ë„ì¿  | ìˆ«ìë¥¼ ì¡°ê±´ì— ë§ê²Œ ì±„ìš°ê¸° |
| ìˆœì—´, ì¡°í•© ìƒì„± | ëª¨ë“  ê°€ëŠ¥í•œ ê²½ìš° ë‚˜ì—´ |

### 5.2 ì—°ê²° ìš”ì†Œ íƒìƒ‰

- DFSëŠ” ê·¸ë˜í”„ì—ì„œ ì—°ê²°ëœ ëª¨ë“  ë…¸ë“œë¥¼ ì°¾ëŠ” ë° ìœ ìš©í•˜ë‹¤. ì˜ˆ: ì—°ê²° ìš”ì†Œì˜ ê°œìˆ˜ êµ¬í•˜ê¸°

### 5.3 ê²½ë¡œ ì°¾ê¸°/ë¯¸ë¡œ íƒìƒ‰

- DFSë¡œ ëª©ì ì§€ê¹Œì§€ ë„ë‹¬í•  ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•˜ê±°ë‚˜ ê²½ë¡œ ìì²´ë¥¼ ì¶”ì í•  ìˆ˜ ìˆë‹¤.

## âœ… 6. DFSë¥¼ í™œìš©í•œ ì‘ìš© ë¬¸ì œ

| ë¬¸ì œ ìœ í˜• | ì„¤ëª… |
|------------|----------------------------|
| ë¯¸ë¡œ ì°¾ê¸° | ê°ˆ ìˆ˜ ìˆëŠ” ê²½ë¡œ ëê¹Œì§€ íƒìƒ‰ |
| ì„¬ì˜ ê°œìˆ˜ | 2ì°¨ì› ë°°ì—´ì„ ê·¸ë˜í”„ë¡œ ë³´ê³  DFS |
| ë‹¨ì–´ ë³€í™˜ | í•œ ë‹¨ê³„ì”© ë³€í™˜í•˜ì—¬ íƒìƒ‰ |
| N-Queen | ë°±íŠ¸ë˜í‚¹ìœ¼ë¡œ ëª¨ë“  ë°°ì¹˜ ê²½ìš° íƒìƒ‰ |

### ì˜ˆì‹œ: "ì„¬ì˜ ê°œìˆ˜" ë¬¸ì œ (2ì°¨ì› DFS)

```python
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

def dfs(x, y):
    if x < 0 or x >= n or y < 0 or y >= m:
        return
    if grid[x][y] == 0:
        return
    grid[x][y] = 0  # ë°©ë¬¸ ì²˜ë¦¬
    for i in range(4):
        dfs(x + dx[i], y + dy[i])
```

## âœ… 7. DFS ì—°ìŠµ ë¬¸ì œ ì¶”ì²œ

| ë‚œì´ë„ | ë¬¸ì œ ë§í¬ |
|--------|------------|
| â­ | [ë°±ì¤€ 11724 - ì—°ê²° ìš”ì†Œì˜ ê°œìˆ˜](https://www.acmicpc.net/problem/11724) |
| â­â­ | [ë°±ì¤€ 4963 - ì„¬ì˜ ê°œìˆ˜](https://www.acmicpc.net/problem/4963) |
| â­â­â­ | [í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ - ë‹¨ì–´ ë³€í™˜](https://school.programmers.co.kr/learn/courses/30/lessons/43163) |
| â­â­â­â­ | [ë°±ì¤€ 9663 - N-Queen](https://www.acmicpc.net/problem/9663) |


## âœ… 8. ë¬¸ì œ í’€ì´

- ë°±ì¤€ 11724 - ì—°ê²° ìš”ì†Œì˜ ê°œìˆ˜
```py
import sys
sys.setrecursionlimit(10**6)
input = sys.stdin.readline 
n, m = map(int, input().split())
d = {i: [] for i in range(1, n+1)}
v = [False] * (n+1)
for _ in range(m):
    a, b = map(int, input().split())
    d[a].append(b)
    d[b].append(a)
def dfs(k):
    v[k] = True
    for r in d[k]:
        if not v[r]:
            dfs(r)
cnt = 0
for i in range(1, n+1):
    if not v[i]:
        dfs(i)
        cnt += 1
print(cnt)
```

> ì´ìŠˆ 1: ëŸ°íƒ€ì„ ì—ëŸ¬ (RecursionError)
> - **ì›ì¸**: DFSê°€ ì¬ê·€ë°©ì‹ìœ¼ë¡œ êµ¬í˜„ë˜ì–´ ìˆê³ , íŒŒì´ì¬ì˜ ê¸°ë³¸ ì¬ê·€ ê¹Œì§€ ë³´í˜¸í•  ìˆ˜ ìˆëŠ” ê°œìˆ˜ëŠ” 1000ê°œ ì •ë„Â â†’ í° ì…ë ¥ì—ì„œ **ì¬ê·€ ê¹Œì§€ ë„˜ì–´ê°ˆ ê²½ìš° ì˜¤ë¥˜ ë°œìƒ**
> - **í•´ê²°**: sys.setrecursionlimit(10**6) â†’ ì¬ê·€ ê¹Œì§€ í•œë„ ë†’ì´ê¸°

> ì´ìŠˆ 2: ì‹œê°„ ì´ˆê³¼ (TLE)
> **ì›ì¸**: `input()` ë©”ì„œë“œëŠ” ì…ë ¥ ì†ë„ê°€ ëŠë¦° í¸Â â†’ ê°œìˆ˜ê°€ ë§ì€ ê²ƒì´ ë°”í€´ë¡œ **ì‹œê°„ ì´ˆê³¼**ì˜ ì£¼ì›ì´ ë¨
> **í•´ê²°**: `sys.stdin.readline()` ì‚¬ìš© í†µí•´ ì…ë ¥ ì†ë„ ê°œì •


- ë°±ì¤€ 4963 - ì„¬ì˜ ê°œìˆ˜
```py
import sys
sys.setrecursionlimit(10000)
input = sys.stdin.readline
w, h = map(int,input().split())
result = []
def dfs(x,y):
    v[x][y] = True
    for dx,dy in [(-1,-1),(-1,0),(-1,1),(1,1),(1,0),(1,-1),(0,-1),(0,1)]:
        nx, ny = x+dx,y+dy
        if 0 <= nx < h and 0 <= ny < w and not v[nx][ny] and g[nx][ny] == 1:
            dfs(nx,ny)
while w!=0 and h!=0:
    g = []
    v = [[False for _ in range(w)] for _ in range(h)]
    cnt = 0
    for _ in range(h):
        g.append(list(map(int,input().split())))
    
    for i in range(h):
        for j in range(w):
            if g[i][j] !=0 and not v[i][j]:
                dfs(i,j)
                cnt+=1
    print(cnt)
    w, h = map(int,input().split())
```
> ì´ìŠˆ 1: ì˜ëª»ëœ ì„¬ ê°œìˆ˜ ì¶œë ¥ (`Wrong Answer`)
> - **ì›ì¸**: ë°©ë¬¸ ì²˜ë¦¬ ë°°ì—´(`v`)ì„ `[[False]*w]*h`ë¡œ ìƒì„±  
>   â†’ ì´ ë°©ì‹ì€ ê°™ì€ ë¦¬ìŠ¤íŠ¸ë¥¼ `h`ë²ˆ ì°¸ì¡°í•˜ëŠ” **ì–•ì€ ë³µì‚¬(shallow copy)**  
>   â†’ í•˜ë‚˜ì˜ í–‰ë§Œ ìˆ˜ì •í•´ë„ **ëª¨ë“  í–‰ì´ ë™ì‹œì— ìˆ˜ì •**ë¨
> - **ê²°ê³¼**: `v[i][j]`ë¥¼ ë°©ë¬¸ ì²˜ë¦¬í–ˆì„ ë•Œ, **ë‹¤ë¥¸ ì¤„ê¹Œì§€ ê°™ì´ ë°©ë¬¸ ì²˜ë¦¬**ë˜ì–´  
>   â†’ **íƒìƒ‰ì´ ì¡°ê¸°ì— ëë‚˜ê³ **, **ì¼ë¶€ ì„¬ì´ íƒìƒ‰ë˜ì§€ ì•ŠìŒ**
> - **í•´ê²°**: ë¦¬ìŠ¤íŠ¸ ë‚´í¬ë¥¼ ì‚¬ìš©í•´ ê° í–‰ì„ **ë…ë¦½ì ìœ¼ë¡œ ìƒì„±**  
> v = [[False for _ in range(w)] for _ in range(h)]


- í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ - ë‹¨ì–´ ë³€í™˜
```py
def solution(begin, target, words):
    v = [False for _ in range(len(words))]
    answer = []
    def dfs(word,cnt):
        if word == target:
            answer.append(cnt)
            return
        
        for i,w in enumerate(words):
            if not v[i] and sum(1 for a,b in zip(word,w) if a==b) == len(word)-1:
                v[i] = True
                dfs(w,cnt+1)
                v[i] = False
                
    dfs(begin,0)
    return min(answer) if answer else 0
```
- ë°±ì¤€ 9663 - N-Queen (ì‹¤íŒ¨)
```py
n = int(input())
answer = 0
g = [[0 for _ in range(n)] for _ in range(n)]
def queen(j,i,v):
    g[j][i] += v
    for idx in range(n):
        if idx != j:
            g[j][idx] += v
    for idx in range(n):
        if idx != i:
            g[idx][i] += v 
    for idx in range(1,n):
        if j+idx < n and i+idx < n:
            g[j+idx][i+idx] += v
        if j-idx >= 0 and i-idx >= 0:
            g[j-idx][i-idx] += v
        if j-idx >= 0 and i+idx < n:
            g[j-idx][i+idx] += v
        if j+idx < n and i-idx >= 0:
            g[j+idx][i-idx] += v
def dfs(j=0):
    global answer
    if j == n:
        answer +=1
        return
    for i in range(n):
        if g[j][i] ==0:
            queen(j,i,1)
            dfs(j+1)
            queen(j,i,-1)
dfs()
print(answer)
```
> ì´ìŠˆ 1: ì‹œê°„ ì´ˆê³¼ (TLE)
> - **ì›ì¸**: 2ì°¨ì› ë°°ì—´ë¡œ ìœ„í˜‘ ë²”ìœ„ë¥¼ ì¼ì¼ì´ í‘œì‹œí•˜ê³  ìˆì–´ì„œ Nì´ ì»¤ì§ˆìˆ˜ë¡ ì—°ì‚°ëŸ‰ì´ ë§ì•„ì§
> - **í•´ê²°**: ??
```py
import sys
input = sys.stdin.readline

def backtrack(row):
    global count
    if row == N:
        count += 1
        return
    for col in range(N):
        if not cols[col] and not diag1[row + col] and not diag2[row - col + N - 1]:
            cols[col] = diag1[row + col] = diag2[row - col + N - 1] = True
            backtrack(row + 1)
            cols[col] = diag1[row + col] = diag2[row - col + N - 1] = False

N = int(input())
count = 0

# ìµœì í™”ë¥¼ ìœ„í•œ ì²´í¬ ë°°ì—´
cols = [False] * N
diag1 = [False] * (2 * N - 1)  # â†˜ ë°©í–¥ ëŒ€ê°ì„ 
diag2 = [False] * (2 * N - 1)  # â†™ ë°©í–¥ ëŒ€ê°ì„ 

backtrack(0)
print(count)
```