--- 
title: "네트워크 | Network" 
date: 2025-04-07 09:00:00 +0900
achieved: 2025-04-07 10:00:00 +0900
math: true
categories: [CS, Network]
tags: [CS, Network]
---
---------- 	
> 내가 볼려고 작성한 CS 공부. 
{: .prompt-info } 


# ⚙️ 네트워크

## ✅ 1. OSI 7계층 & TCP/IP 4계층

### 1.1 OSI 7계층이란?

> OSI 7계층(Open Systems Interconnection)은 **네트워크 통신을 7단계로 나눈 표준 모델**이다.  
> 각 계층은 서로 독립적이면서, 상호 협력하여 데이터를 주고받는다.

```plaintext
[사용자]
7. 응용 계층 (Application)
6. 표현 계층 (Presentation)
5. 세션 계층 (Session)
4. 전송 계층 (Transport)
3. 네트워크 계층 (Network)
2. 데이터 링크 계층 (Data Link)
1. 물리 계층 (Physical)
[하드웨어]
```
> 하위 계층은 상위 계층에게 서비스를 제공하고,  
> 상위 계층은 하위 계층의 기능에 의존한다.

### 1.2 각 계층 설명

| 계층 | 주요 기능 | 예시 |
|------|-----------|------|
| 7. 응용 계층 | 사용자와 가장 가까운 계층 (웹, 메일 등) | HTTP, FTP, SMTP |
| 6. 표현 계층 | 데이터 포맷 변환, 암호화/복호화 | JPEG, PNG, SSL |
| 5. 세션 계층 | 연결 유지, 동기화 | API 호출 세션 |
| 4. 전송 계층 | 데이터의 안정적 전송 | TCP, UDP |
| 3. 네트워크 계층 | 주소 지정, 경로 설정 (IP) | IP, ICMP, 라우팅 |
| 2. 데이터 링크 계층 | 프레임 단위 전송, MAC 주소 사용 | Ethernet, MAC |
| 1. 물리 계층 | 전기적 신호, 비트 전송 | 케이블, 허브, 전파 |

> 실무에서는 보통 **1~4계층은 시스템/네트워크**,  
> **5~7계층은 소프트웨어/애플리케이션** 영역으로 나눈다.



### 1.3 TCP/IP 4계층

> OSI 7계층보다 실용적이고 간단한 구조로, **인터넷에서 실제 사용되는 네트워크 모델**

| TCP/IP 계층 | OSI 계층 대응 | 설명 |
|-------------|----------------|------|
| 4. 응용 계층 | OSI 5~7계층 | HTTP, DNS, FTP 등 |
| 3. 전송 계층 | OSI 4계층 | TCP, UDP |
| 2. 인터넷 계층 | OSI 3계층 | IP, ICMP |
| 1. 네트워크 인터페이스 계층 | OSI 1~2계층 | LAN, MAC, 이더넷 |

> TCP/IP는 **실제 구현 기준**,  
> OSI는 **이론적 설계 기준**이라고 생각하면 이해가 쉽다.

### 1.4 OSI vs TCP/IP 계층 비교

| OSI 7계층 | TCP/IP 4계층 |
|-----------|----------------|
| 응용 | 응용 |
| 표현 | (통합) |
| 세션 | (통합) |
| 전송 | 전송 |
| 네트워크 | 인터넷 |
| 데이터 링크 | 네트워크 인터페이스 |
| 물리 | 네트워크 인터페이스 |

> 실무에서는 대부분 **TCP/IP 4계층** 용어를 더 많이 사용한다.

## ✅ 2. HTTP / HTTPS, DNS, DHCP



### 2.1 HTTP (HyperText Transfer Protocol)

> HTTP는 **웹에서 클라이언트(브라우저)와 서버 간 데이터를 주고받는 프로토콜**이다.  
> 요청(Request)과 응답(Response)으로 구성되며, **비연결형, 비상태형**이 특징이다.

| 특징 | 설명 |
|------|------|
| 비연결형 | 요청 후 연결 종료 (매 요청마다 새로 연결) |
| 비상태형 | 이전 요청 정보를 기억하지 않음 (쿠키/세션으로 보완) |
| 포트 번호 | 기본 80번 포트 사용 |
| 요청 방식 | GET, POST, PUT, DELETE 등 |

#### 예시

```plaintext
GET /index.html HTTP/1.1
Host: www.example.com
```
> 클라이언트가 index.html 요청 → 서버가 HTML 파일 응답

### 2.2 HTTPS (HTTP Secure)

> HTTPS는 **HTTP에 SSL/TLS를 적용해 데이터 통신을 암호화한 프로토콜**이다.  
> 민감한 정보를 다룰 때(로그인, 결제 등) 반드시 사용된다.

| 항목 | HTTP | HTTPS |
|------|------|-------|
| 보안 | 없음 | 암호화 적용 (TLS/SSL) |
| 포트 | 80 | 443 |
| 인증서 사용 | X | O (공개키 기반 인증서 필요) |

> SSL은 과거 명칭, 현재는 대부분 **TLS**로 대체됨


### 2.3 DNS (Domain Name System)

> DNS는 사용자가 입력한 **도메인 이름(www.google.com)** 을 **실제 서버의 IP 주소(142.250.206.36)** 로 변환해주는 시스템이다.

#### 동작 흐름

1. 사용자가 브라우저에 도메인 입력  
2. 로컬 DNS 캐시 확인  
3. ISP DNS 서버 → 루트 → TLD → 권한 있는 네임서버 순으로 탐색  
4. 최종적으로 **IP 주소를 반환**

> DNS는 웹사이트 접속의 시작점이며,  
> 속도 개선을 위해 **캐싱**이 매우 중요하다.


### 2.4 DHCP (Dynamic Host Configuration Protocol)

> DHCP는 **네트워크에 연결된 장치에게 IP 주소를 자동으로 할당해주는 프로토콜**이다.

| 과정 단계 | 설명 |
|-----------|------|
| DHCP Discover | 클라이언트가 브로드캐스트로 IP 요청 |
| DHCP Offer | 서버가 IP와 정보 제안 |
| DHCP Request | 클라이언트가 해당 IP 요청 |
| DHCP Ack | 서버가 승인 및 설정 완료 |

> DHCP 없으면 매번 수동으로 IP, 게이트웨이, DNS를 설정해야 함  
> 대부분의 가정/기업 네트워크는 DHCP 기반


### 2.5 각 역할 요약

| 프로토콜 | 역할 |
|----------|------|
| HTTP | 웹 문서 전송 (비보안) |
| HTTPS | 보안 웹 통신 |
| DNS | 도메인 → IP 변환 |
| DHCP | IP 자동 할당 |


## ✅ 3. TCP vs UDP

### 3.1 TCP (Transmission Control Protocol)

> TCP는 **신뢰성 있는 연결 지향형 전송 프로토콜**이다.  
> 데이터가 **순서대로, 손실 없이** 정확히 전달되도록 보장한다.

#### 주요 특징

| 항목 | 설명 |
|------|------|
| 연결 방식 | 연결 지향 (3-way handshake 필요) |
| 데이터 순서 보장 | 보장함 |
| 데이터 손실 보정 | 재전송 기능 있음 |
| 흐름 제어 / 혼잡 제어 | 있음 |
| 속도 | 상대적으로 느림 (신뢰성 보장 때문) |
| 대표 사용 | 웹(HTTP/HTTPS), 메일(SMTP), 파일 전송(FTP)

> TCP는 **정확성과 안정성**이 중요한 서비스에 적합하다.

### 3.2 UDP (User Datagram Protocol)

> UDP는 **비연결형, 비신뢰성 전송 프로토콜**이다.  
> 데이터를 빠르게 보내지만, 순서 보장이나 재전송은 하지 않는다.

#### 주요 특징

| 항목 | 설명 |
|------|------|
| 연결 방식 | 비연결형 (handshake 없음) |
| 데이터 순서 보장 | 없음 |
| 데이터 손실 보정 | 없음 |
| 흐름 제어 / 혼잡 제어 | 없음 |
| 속도 | 빠름 |
| 대표 사용 | 실시간 스트리밍, VoIP, 게임, DNS

> UDP는 **속도가 중요하고, 약간의 손실이 허용되는 서비스**에 적합하다.


### 3.3 TCP vs UDP 비교표

| 항목 | TCP | UDP |
|------|-----|-----|
| 연결 방식 | 연결 지향 | 비연결형 |
| 신뢰성 | 높음 (순서, 무결성 보장) | 낮음 (순서X, 손실 가능) |
| 속도 | 느림 | 빠름 |
| 오버헤드 | 큼 | 작음 |
| 대표 예시 | HTTP, FTP, SMTP | DNS, 게임, 영상 스트리밍


### 3.4 실제 활용 비교 예

- **웹 브라우징, 로그인, 파일 다운로드** → TCP (데이터 정확성 필수)  
- **온라인 게임, 음성 통화, 유튜브 영상** → UDP (약간의 손실 허용, 빠른 응답 우선)

> "안정성"을 우선시하면 TCP,  
> "속도"와 "실시간성"을 우선시하면 UDP!

## ✅ 4. 3-way & 4-way Handshake


### 4.1 3-way Handshake (연결 시작)

> TCP는 **신뢰성 있는 연결을 보장하기 위해**,  
> 데이터를 주고받기 전 반드시 **3단계 연결 수립 절차**를 수행한다.

```plaintext
[클라이언트]               [서버]
     SYN   ─────────▶  
            (연결 요청)

     SYN-ACK ◀────────
            (요청 수락 + 응답)

     ACK    ─────────▶
            (수락 확인)

연결 수립 완료 → 데이터 통신 시작
```
| 단계 | 메시지 | 설명 |
|------|--------|------|
| 1단계 | SYN | 클라이언트가 서버에 연결 요청 |
| 2단계 | SYN-ACK | 서버가 수신 확인 및 연결 승인 |
| 3단계 | ACK | 클라이언트가 수락 완료 |

> 이 과정을 통해 **양쪽 모두 연결 의사를 확인하고**,  
> **시퀀스 번호를 교환**해 데이터 순서를 맞출 준비를 한다.


### 4.2 4-way Handshake (연결 종료)

> TCP 연결을 끊을 때는 **각 방향마다 종료를 따로 처리**하기 때문에 4단계가 필요하다.

```plaintext
[클라이언트]               [서버]
     FIN   ─────────▶  
            (보낼 데이터 없음)

     ACK   ◀────────
            (수신 확인)

     FIN   ◀────────
            (서버도 종료 요청)

     ACK   ─────────▶
            (서버 종료 수락)

연결 종료 완료
```
| 단계 | 메시지 | 설명 |
|------|--------|------|
| 1단계 | FIN | 클라이언트가 연결 종료 요청 |
| 2단계 | ACK | 서버가 FIN 수신 확인 |
| 3단계 | FIN | 서버도 종료 요청 |
| 4단계 | ACK | 클라이언트가 종료 수락 |

> 종료는 **양방향 통신이기 때문에**,  
> **각 방향의 종료 요청을 따로 처리**해야 해서 4단계가 필요하다.


### 4.3 상태 변화 요약 (TCP 상태 다이어그램 요약)

| 상태 | 설명 |
|------|------|
| LISTEN | 서버가 연결 요청 대기 중 |
| SYN-SENT | 클라이언트가 SYN 보낸 직후 |
| SYN-RECEIVED | 서버가 SYN 받고 SYN-ACK 보낸 상태 |
| ESTABLISHED | 연결 완료, 데이터 전송 가능 |
| FIN-WAIT | 종료 요청 후 대기 상태 |
| TIME-WAIT | 마지막 ACK 보내고 일정 시간 대기 (지연 패킷 방지용)

> TIME-WAIT는 클라이언트가 마지막 ACK를 보낸 후 **지연된 패킷 유입을 막기 위해 일정 시간 대기**하는 상태다.


## ✅ 5. 로드 밸런싱, CDN, Proxy, NAT


### 5.1 로드 밸런싱 (Load Balancing)

> 로드 밸런싱은 **다수의 서버에 트래픽을 분산**시켜  
> 하나의 서버에 부하가 몰리지 않게 해주는 기술이다.

| 특징 | 설명 |
|------|------|
| 목적 | 서버 간 부하 분산, 고가용성 |
| 동작 위치 | L4 (TCP) 또는 L7 (HTTP) |
| 알고리즘 | Round Robin, Least Connection, IP Hash 등 |

#### 구성 예시

```plaintext
[클라이언트]
      │
  [로드 밸런서]
  ┌────┴────┐
[서버1]  [서버2]
```
> 로드 밸런서는 클라이언트 요청을 받아 **가장 적절한 서버로 전달**해준다.


### 5.2 CDN (Content Delivery Network)

> CDN은 **전 세계 여러 위치에 콘텐츠 복제본을 배포**해,  
> 사용자에게 **가장 가까운 서버에서 빠르게 제공**하는 기술이다.

| 특징 | 설명 |
|------|------|
| 목적 | 전송 속도 향상, 지연 최소화 |
| 방식 | 전 세계에 캐시 서버(Edge Node) 배포 |
| 예시 | 이미지, JS, 동영상 등 정적 콘텐츠

> 클라이언트는 원래 서버(origin)가 아닌, **가장 가까운 CDN 서버로부터 응답**을 받는다.


### 5.3 프록시 서버 (Proxy)

> 프록시는 **클라이언트와 서버 사이에 중간자 역할**을 하는 서버다.  
> **보안, 캐시, 필터링** 등의 목적을 가진다.

| 유형 | 설명 |
|------|------|
| 정방향 프록시 | 클라이언트가 직접 프록시를 거쳐 외부 요청 |
| 역방향 프록시 | 외부 요청을 받아 내부 서버로 전달 (ex: 로드밸런서 역할도 가능)

#### 예시

```plaintext
클라이언트 → 프록시 서버 → 외부 서버
```
> 기업 내부에서 외부 접속 감시/제어,  
> 또는 서버 앞단에서 **보안·캐싱·SSL 종료** 등 역할

### 5.4 NAT (Network Address Translation)

> NAT는 **사설 IP를 공인 IP로 변환**해주는 라우터 기술이다.  
> 하나의 공인 IP만으로도 여러 장치가 인터넷에 접속 가능하게 해준다.

| 구분 | 설명 |
|------|------|
| 사용 위치 | 가정 공유기, 회사 라우터 |
| 필요성 | IPv4 주소 부족 문제 해결 |
| 작동 방식 | 내부 IP ↔ 외부 IP 주소/포트 매핑

> NAT는 **외부에서 직접 내부 장치로 접근 불가능**하기 때문에  
> 서버 운영 시 **포트 포워딩**이 필요하다.

### 5.5 핵심 요약

| 기술 | 주요 역할 |
|------|-----------|
| 로드 밸런싱 | 트래픽 분산 (서버 부하 분산) |
| CDN | 콘텐츠 전송 최적화 |
| Proxy | 중개 서버 (보안, 캐시, 감시) |
| NAT | 사설 IP ↔ 공인 IP 변환


## ✅ 6. 보안: SSL/TLS, 인증, 암호화


### 6.1 SSL / TLS

> SSL은 **데이터를 암호화해서 전송하는 보안 프로토콜**이며,  
> 현재는 대부분 그 후속 버전인 **TLS (Transport Layer Security)** 를 사용한다.

| 항목 | SSL | TLS |
|------|-----|-----|
| 상태 | 더 이상 사용 안 함 | 현재 표준 |
| 목적 | 암호화, 무결성, 인증 보장 |
| 사용처 | HTTPS, 메일, VPN 등 다양한 보안 통신

> TLS는 **중간자 공격, 도청, 위변조**를 방지하기 위해 사용된다.


### 6.2 HTTPS와 TLS의 관계

> HTTPS는 **HTTP + TLS** 조합으로,  
> **웹 통신을 암호화된 채널로 전환**한 것이다.

```plaintext
클라이언트 ---TLS 암호화--> 서버
       (HTTP 요청은 암호화되어 전송됨)
```
> 서버는 TLS 인증서를 통해 신뢰성을 증명하고,  
> 이후 클라이언트와 암호화된 데이터만 주고받는다.


### 6.3 대칭키 vs 비대칭키 암호화

| 항목 | 대칭키 암호화 | 비대칭키 암호화 |
|------|----------------|------------------|
| 키 종류 | 하나 (공용 키) | 공개키 + 개인키 (2개) |
| 속도 | 빠름 | 느림 |
| 보안 위험 | 키 유출 위험 큼 | 키 공유 불필요 (보안 ↑) |
| 사용 예 | TLS 내부 세션, VPN 등 | 인증서, 전자서명 등 |

> TLS에서는 초기 연결 시 비대칭키로 키 교환 → 이후 통신은 대칭키로 빠르게 암호화


### 6.4 인증(Authentication)

> 인증이란 **접속 주체가 신뢰할 수 있는 존재인지 확인**하는 과정이다.

| 종류 | 설명 |
|------|------|
| 기본 인증 | 아이디/비밀번호 (가장 단순) |
| 토큰 기반 | JWT, OAuth 등 인증 후 토큰 사용 |
| 인증서 기반 | TLS 인증서 사용 (공개키 기반 구조) |

> HTTPS는 **공개키 기반 인증서(PKI)** 를 통해 서버의 신원을 검증한다.


### 6.5 암호화(Encryption)의 핵심 개념

| 개념 | 설명 |
|------|------|
| 암호화 | 평문 → 암호문으로 변환 |
| 복호화 | 암호문 → 평문으로 복원 |
| 키(Key) | 암호화/복호화에 사용되는 값 |
| 무결성 | 데이터가 변경되지 않았음을 보장 (ex: HMAC, SHA) |
| 기밀성 | 제3자가 내용을 볼 수 없도록 보호 |
| 인증성 | 보낸 사람이 진짜인지 확인


### 6.6 웹 보안 흐름 요약 (HTTPS)

1. 브라우저가 서버에 접속 (HTTPS)
2. 서버가 TLS 인증서를 클라이언트에게 전달
3. 브라우저가 인증서 검증 (신뢰된 기관인지 확인)
4. 비대칭키로 **세션키 교환**
5. 세션키 기반 **대칭키 암호화 통신 시작**

> 즉, TLS는 **공개키로 인증 + 개인키로 세션 보안**이라는 이중 구조로 동작한다

