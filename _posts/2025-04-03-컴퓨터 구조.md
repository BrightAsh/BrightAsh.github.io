--- 
title: "컴퓨터 구조 | Computer Structure" 
date: 2025-04-03 09:00:00 +0900
achieved: 2025-04-03 10:00:00 +0900
math: true
categories: [CS, Computer Structure]
tags: [CS, Computer Structure]
---
---------- 	
> 내가 볼려고 작성한 CS 공부. 
{: .prompt-info } 


# ⚙️ 컴퓨터 구조 – 컴퓨터의 기본 구성 요소

컴퓨터는 데이터를 입력받고, 처리하고, 저장한 뒤, 그 결과를 사용자에게 출력하는 장치다.  
이 과정을 가능하게 하는 핵심 부품들을 **컴퓨터의 5대 구성 요소**라고 부른다.

## ✅ 1. 중앙처리장치 (CPU, Central Processing Unit)

> CPU는 컴퓨터의 두뇌로, 명령어를 해석하고 실행하며 전체 흐름을 제어하는 장치다.

### 1.1 역할
- 메모리에서 명령어를 가져오고(fetch), 해석하고(decode), 실행한다(execute).
- 계산, 분기, 제어 신호 전송 등 대부분의 실제 작업을 담당한다.

### 1.2 구성 요소

- **ALU (Arithmetic Logic Unit)**  
  : 덧셈, 뺄셈 등의 산술 연산과 AND, OR 같은 논리 연산을 수행  
  > ALU: 계산과 논리 판단을 담당하는 CPU 내부 연산 장치

- **CU (Control Unit)**  
  : 명령어를 해석하고, 각 구성 요소에 필요한 제어 신호를 보낸다  
  > CU: 컴퓨터 내부 흐름을 제어하는 지휘자 역할

- **레지스터 (Register)**  
  : 계산 도중 필요한 데이터를 임시로 저장하는 아주 빠른 저장소  
  > 레지스터: CPU 내부에 있는 초고속 임시 메모리

## ✅ 2. 메모리 (Memory)

> 메모리는 프로그램 실행 중 필요한 데이터를 임시로 저장하는 공간이다.

### 2.1 역할
- CPU가 실행할 명령어와 데이터를 보관한다.
- 실행 중인 프로그램의 작업 공간으로 사용된다.

### 2.2 종류

- **RAM (Random Access Memory)**  
  : 현재 실행 중인 프로그램과 데이터를 저장하며, 전원이 꺼지면 내용이 사라진다  
  > RAM: 빠르게 읽고 쓸 수 있는 휘발성 주기억장치

- **ROM (Read Only Memory)**  
  : 읽기 전용으로, 전원이 꺼져도 내용이 유지된다  
  > ROM: 컴퓨터 부팅에 필요한 기본 정보를 저장하는 비휘발성 메모리

- **보조기억장치와의 구분**  
  : SSD, HDD 같은 저장장치는 메모리와 달리 데이터를 **영구 보관**한다  
  > 보조기억장치: 프로그램 설치, 문서 저장 등에 사용되는 장기 저장소

## ✅ 3. 입력장치 (Input Device)

> 입력장치는 사용자의 명령이나 데이터를 컴퓨터로 전달하는 장치다.

### 3.1 역할
- 사용자의 입력을 디지털 신호로 변환하여 시스템에 전달한다.

### 3.2 예시
- 키보드, 마우스, 마이크, 터치스크린, 카메라 등

## ✅ 4. 출력장치 (Output Device)

> 출력장치는 처리된 결과를 사용자에게 보여주는 장치다.

### 4.1 역할
- 컴퓨터가 계산한 결과를 사람이 이해할 수 있는 형태로 변환해 전달한다.

### 4.2 예시
- 모니터, 프린터, 스피커 등

## ✅ 5. 제어장치 (Control Unit)

> 전통적으로는 독립된 구성 요소로 설명되지만, 실제로는 CPU 내부에 포함된다.

### 5.1 역할
- 입력장치, 메모리, 출력장치 사이의 데이터 흐름을 제어한다.
- 명령어의 흐름을 조정하고 전체 시스템 동작을 감독한다.


## ✅2. 구성 요소 간 데이터 흐름

1. **입력장치**로부터 명령이나 데이터 입력
2. **메모리**에 명령어와 데이터를 저장
3. **CPU**가 명령어를 가져와서 해석하고 처리
4. 결과를 다시 **메모리**에 저장하거나
5. **출력장치**를 통해 사용자에게 결과 전달

> 이 과정을 "펫치(Fetch) → 디코드(Decode) → 실행(Execute)" 사이클이라고 부른다.


## ✅3. 구조적 배경: 폰 노이만 구조

> 💡 오늘날 대부분의 컴퓨터는 "폰 노이만 구조(Von Neumann Architecture)"를 따른다.

### 특징
- **명령어와 데이터를 같은 메모리에 저장**
- CPU와 메모리 사이에 **하나의 버스(bus)**로 연결됨  
  > 버스: 컴퓨터 내부의 데이터 전달 통로 (전선의 고속도로라고 생각하면 됨)

### 단점
- 명령어와 데이터가 같은 통로(버스)를 쓰다 보니 **속도 병목 현상** 발생  
  > 이를 **폰 노이만 병목(Von Neumann Bottleneck)**이라고 한다.


<br>
<br>
<br>

---
# ⚙️ 컴퓨터 구조 – CPU, 메모리, 저장장치, 버스 구조

컴퓨터는 데이터를 입력받고, 처리하고, 저장하고, 출력하는 구조다.  
이 과정에서 가장 중요한 구성 요소가 바로:

- **CPU (중앙처리장치)**
- **메모리 (주기억장치)**
- **저장장치 (보조기억장치)**
- **버스 (데이터 통로)**

## ✅ 1. CPU (Central Processing Unit) – 컴퓨터의 두뇌

> 💡 CPU는 컴퓨터가 명령어를 해석하고 실행하는 "두뇌"다.

### 역할
- 프로그램 명령어를 하나씩 **가져오고(Fetch)**  
- **해석하고(Decode)**  
- **실행(Execute)** 한다.

### 내부 구성

| 구성 요소 | 역할 |
|-----------|------|
| ALU (산술 논리 연산 장치) | 계산 담당 (예: 덧셈, 비교 등) |
| CU (제어 장치) | 명령어 해석 및 제어 신호 전달 |
| 레지스터 | CPU 내부의 초고속 임시 저장 공간 |


### 작동 사이클
1. 명령어를 메모리에서 **가져오고**
2. 그 명령어를 **해석한 뒤**
3. ALU로 계산을 수행하거나, 메모리에 접근함

---

## ✅ 2. 메모리 (Memory) – CPU의 작업 공간

> 💡 메모리는 CPU가 실행 중인 프로그램과 데이터를 저장하는 **임시 작업 공간**이다.

### RAM vs ROM

| 종류 | 설명 | 특성 |
|------|------|------|
| RAM (휘발성 메모리) | 실행 중인 프로그램 & 데이터 저장 | 전원 끄면 데이터 사라짐 |
| ROM (비휘발성 메모리) | 시스템 초기화 정보 저장 | 데이터 고정, 변경 불가 |

### 메모리의 특징
- CPU는 RAM에 있는 데이터를 실시간으로 사용
- RAM이 부족하면 속도 저하 → 디스크 스와핑 발생


## ✅ 3. 저장장치 (Storage) – 데이터를 오래 저장하는 공간

### 종류

| 장치 | 설명 | 특성 |
|------|------|------|
| HDD (하드디스크) | 자성 원판이 회전하며 데이터를 읽고 씀 | 가격 저렴, 속도 느림 |
| SSD (솔리드 스테이트 드라이브) | 반도체 기반 플래시 메모리 | 속도 빠름, 비쌈 |
| 외장장치 | USB, 외장 HDD 등 | 휴대 가능, 백업용 |

### 메모리 vs 저장장치

| 구분 | 메모리 (RAM) | 저장장치 (SSD, HDD 등) |
|------|--------------|-------------------------|
| 목적 | 실시간 작업 처리 | 데이터 보관 |
| 속도 | 매우 빠름 | 상대적으로 느림 |
| 휘발성 | O (전원 끄면 사라짐) | X (전원 꺼도 유지됨) |

---

## ✅ 4. 버스 (Bus) – 부품 간 연결 통로

> 💡 버스는 컴퓨터 내부에서 데이터를 전달하는 **전선 묶음** 같은 통로다.

### 역할
- CPU, 메모리, 저장장치, 입출력장치를 **서로 연결**함
- 데이터, 주소, 제어 신호를 전달하는 **고속 통신로**

### 버스의 종류

| 버스 종류 | 설명 |
|-----------|------|
| 데이터 버스 | 실제 데이터를 전달 |
| 주소 버스 | 데이터가 어디에 있는지를 지정 |
| 제어 버스 | 읽기/쓰기 등 동작을 지시 |

> 🔍 **데이터 버스**: 예) 42라는 숫자를 메모리로 보낼 때 그 42 자체를 전달  
> 🔍 **주소 버스**: 예) 0x1234 메모리 위치로 가! 라고 알려줌  
> 🔍 **제어 버스**: 예) 이건 읽기(Read)야! 라고 명령

### 병목 현상: "폰 노이만 병목"

> 명령어와 데이터가 같은 버스를 타고 움직이기 때문에  
> 동시에 처리하려고 하면 **속도 병목(bottleneck)**이 생긴다.

<br>
<br>
<br>

---
# ⚙️ 컴퓨터 구조 – 캐시 메모리와 계층적 메모리 구조

CPU, RAM, 저장장치(SSD/HDD) 사이에는 **속도와 비용의 차이**가 있다.  
이 차이를 극복하고 **전체 시스템 성능을 높이기 위한 구조**가 바로 **계층적 메모리 구조**이고 그 핵심 요소가 **캐시 메모리(Cache Memory)**이다.


## ✅ 1. 왜 계층적 메모리 구조가 필요한가?

> 💡 CPU는 아주 빠르게 동작하지만, 메모리는 상대적으로 느리다.  
> 이로 인해 CPU가 데이터를 기다리며 **놀게 되는 시간(idle time)**이 많아짐.

### 예시
- CPU는 나노초(ns) 단위로 작동  
- RAM은 그보다 훨씬 느림 → CPU가 RAM 응답을 기다려야 함  
- 저장장치는 RAM보다도 수십~수천 배 느림 (특히 HDD)

그래서 메모리 구조에 **속도 차이를 줄이는 중간 단계**가 필요했고 바로 그게 **캐시(Cache)**다.


## ✅ 2. 계층적 메모리 구조란?

> 💡 "빠르지만 비싼 메모리"와 "느리지만 싼 메모리"를 **계층적으로 섞어 사용**하는 구조

### 계층 구성 (빠름 ↔ 느림 / 작음 ↔ 큼)

| 계층 | 종류 | 속도 | 크기 | 비고 |
|------|------|------|------|------|
| 1단계 | **레지스터** | 🟢 매우 빠름 | 🔴 매우 작음 | CPU 내부 |
| 2단계 | **L1 캐시** | 🟢 빠름 | 🔴 작음 (KB 단위) | CPU 코어당 존재 |
| 3단계 | **L2 캐시** | 🟡 중간 | 🟡 중간 (수백 KB~MB) | 보통 코어당 1개 |
| 4단계 | **L3 캐시** | 🔵 느림 | 🟢 큼 (수 MB~수십 MB) | CPU 전체가 공유 |
| 5단계 | **RAM (주기억장치)** | 🔵 더 느림 | 🟢 큼 (GB 단위) | 모든 실행 중 데이터 저장 |
| 6단계 | **SSD/HDD (보조기억장치)** | 🔴 매우 느림 | 🟢 매우 큼 (TB 단위) | 프로그램, 파일 저장소 |


## ✅ 3. 캐시 메모리란?

> 💡 **자주 사용하는 데이터**를 CPU 근처에 빠르게 접근 가능한 형태로 **미리 저장해두는 메모리**

### 핵심 특징
- **작고 빠르다**
- RAM보다 훨씬 빠름
- CPU와 가까운 위치에 있음

### 왜 필요한가?
- CPU가 **같은 데이터를 반복해서 사용할 때** RAM까지 안 가고, 캐시에서 바로 가져옴
- RAM 접근 시간을 줄여서 전체 연산 속도를 높여줌

## ✅ 4. 캐시 메모리의 작동 원리

### 작동 흐름
1. CPU가 어떤 데이터를 요청함
2. **캐시에 해당 데이터가 있으면 → 바로 사용** (→ **캐시 히트**)
3. **없으면 → RAM에서 가져오고 캐시에 저장** (→ **캐시 미스**)

## ✅ 5. 캐시의 계층 (L1, L2, L3)

| 구분 | 설명 |
|------|------|
| **L1 캐시** | 가장 빠르고 가장 작음 (CPU 코어당 존재, 보통 32~128KB) |
| **L2 캐시** | 중간 속도 & 크기 (CPU 코어당 존재하거나 공유, 수백 KB~1MB) |
| **L3 캐시** | CPU 전체가 공유하는 캐시 (수 MB, 여러 코어 간 통신에도 사용) |

> 각 계층은 데이터 요청 시 **순차적으로 탐색**됨 (L1 → L2 → L3 → RAM)


## ✅ 6. 캐시 메모리 정책 (심화)

### 교체 정책 (Cache Replacement Policy)

> 캐시는 용량이 작아서 오래된 데이터를 **비워야 할 때** 어떤 데이터를 버릴지를 결정

- **LRU (Least Recently Used)**  
  → 가장 오래 전에 사용된 데이터를 제거  
- **FIFO (First In First Out)**  
  → 먼저 들어온 데이터를 먼저 제거  
- **Random**  
  → 무작위로 하나 선택해서 제거

## ✅ 7. 계층적 구조의 효과

- **속도와 비용의 균형**을 잡을 수 있음
- 자주 쓰는 데이터는 빠른 메모리(L1~L3 캐시)에  
- 덜 쓰는 데이터는 느리지만 싼 저장장치(SSD/HDD)에


<br>
<br>
<br>

---
# ⚙️ 컴퓨터 구조 – 명령어 사이클 & 파이프라이닝


## ✅ 1. 명령어 사이클 (Instruction Cycle)이란?

> 💡 컴퓨터가 프로그램을 실행한다는 것은, 메모리에 있는 **명령어를 하나씩 읽고, 해석하고, 실행하는 것**이다. 이 과정을 **명령어 사이클**이라고 한다.

### 명령어 사이클의 3단계

| 단계 | 설명 |
|------|------|
| **Fetch** | 메모리에서 명령어를 가져옴 |
| **Decode** | 명령어를 해석하여 무엇을 해야 하는지 파악 |
| **Execute** | 실제로 연산, 데이터 이동 등의 동작 수행 |

## ✅ 2. 명령어 사이클의 흐름

### 예시: `A = B + C` 라는 명령어 실행 과정

1. **Fetch**: `A = B + C` 명령어를 RAM에서 CPU로 가져옴
2. **Decode**: ‘+’ 연산을 해야 한다는 것을 CU가 해석
3. **Execute**: ALU가 B와 C를 더해 A에 저장

> 💡 이 과정이 **1개의 명령어마다 반복됨**

## ✅ 3. 파이프라이닝 (Pipelining)이란?

> 💡 CPU가 명령어들을 **겹쳐서 동시에 처리**하는 기술  
> 마치 공장에서 여러 작업을 **줄 세워 병렬로 수행**하는 것처럼 작동함

### 공장 비유 예시

| 작업 | 사람1 | 사람2 | 사람3 |
|------|-------|-------|-------|
| 작업1 | 잘라 |       |       |
| 작업2 | 잘라 | 조립 |       |
| 작업3 | 잘라 | 조립 | 포장 |
| 작업4 | 잘라 | 조립 | 포장 |

## ✅ 4. 명령어 사이클과 파이프라이닝의 관계

| 일반 처리 (Non-pipelined) | 파이프라인 처리 |
|--------------------------|------------------|
| 한 명령어를 Fetch → Decode → Execute 순서대로 처리하고 나서 다음 명령어 처리 | 여러 명령어의 각 단계가 **동시에 진행**됨 |

📌 예:
- 일반: A → B → C 순차적으로 3초
- 파이프라인: A/B/C가 1초 간격으로 겹쳐져서 총 5초가 3초로 단축됨

## ✅ 5. 파이프라이닝 구조 예시 (5단계 파이프라인)

| 단계 | 이름 | 설명 |
|------|------|------|
| IF | Instruction Fetch | 명령어 가져오기 |
| ID | Instruction Decode | 명령어 해석 |
| EX | Execute | 연산 수행 |
| MEM | Memory Access | 메모리 접근 |
| WB | Write Back | 결과 저장 |

> 💡 실제 CPU는 이 단계를 동시에 수행하여 속도를 극대화함

## ✅ 6. 파이프라이닝의 문제점 (Hazard, 위험 요소)

### 6.1 데이터 해저드 (Data Hazard)
- 다음 명령이 이전 명령의 결과를 **기다려야 할 때**

### 6.2 제어 해저드 (Control Hazard)
- 분기문(if, jump 등)으로 인해 **어떤 명령을 실행할지 결정되지 않았을 때**

### 6.3 구조적 해저드 (Structural Hazard)
- 하드웨어 자원이 **겹쳐서 충돌** 날 때 (예: 두 명령이 동시에 메모리를 사용하려 함)

> 💡 **해저드(Hazard)**: 파이프라인 처리 중 발생하는 충돌/지연 문제

## ✅ 7. 파이프라이닝 성능 효과

- 파이프라이닝이 없다면: 명령어 N개 처리에 N x 1단계 시간 소요  
- 파이프라이닝이 있으면: N + (단계 수 - 1) 시간 소요  
- 즉, 전체 명령어 처리 시간이 **크게 줄어든다**

<br>
<br>
<br>

---
# ⚙️ 컴퓨터 구조 – 병렬처리와 멀티코어 (Parallel Processing & Multicore)


## ✅ 1. 병렬처리란?

> 💡 병렬처리는 **여러 작업을 동시에 수행**하는 처리 방식이다.

### 왜 중요한가?
- 더 많은 데이터를 더 빠르게 처리할 수 있음
- CPU 성능을 높이기 위한 핵심 기술


## ✅ 2. 병렬처리의 기본 개념

### 직렬 처리 vs 병렬 처리

| 구분 | 직렬 처리 (Serial) | 병렬 처리 (Parallel) |
|------|-------------------|----------------------|
| 처리 방식 | 작업을 **하나씩 순서대로** 수행 | 여러 작업을 **동시에 수행** |
| 예시 | 요리를 혼자서 하나씩 함 | 여러 명이 재료 손질, 요리, 설거지 나눠서 동시에 함 |

---

## ✅ 3. 병렬처리의 유형

### 3.1 데이터 병렬 처리 (Data Parallelism)
- 같은 작업을 여러 데이터에 동시에 적용  
> 예: 수천 개 이미지에 같은 필터 적용

### 3.2 작업 병렬 처리 (Task Parallelism)
- 서로 다른 작업을 동시에 수행  
> 예: 한 프로세스는 영상 처리, 다른 프로세스는 소리 처리

## ✅ 4. 멀티코어란?

> 💡 멀티코어는 하나의 CPU 칩 안에 **여러 개의 독립적인 코어**(작은 CPU)를 넣은 것

> **코어(Core)**: 실제로 계산을 수행하는 처리 유닛.  
> 과거에는 CPU = 코어 1개였지만, 지금은 보통 4~16개 이상 존재

### 왜 생겼을까?
- CPU 클럭 속도를 무작정 높이는 건 발열/전력/한계가 있음
- 대신 여러 코어를 넣어 병렬로 처리 → 성능 향상

## ✅ 5. 멀티코어 시스템에서 병렬 처리

| 구조 | 설명 |
|------|------|
| 싱글코어 | 한 번에 한 작업만 수행 가능 |
| 듀얼코어 | 동시에 두 개의 작업 수행 가능 |
| 쿼드코어 이상 | 더 많은 병렬 작업 가능 |

운영체제는 각 코어에 **프로세스나 스레드**를 배분해 동시 실행

## ✅ 6. 병렬처리 관련 기술

| 기술 | 설명 |
|------|------|
| 스레드 (Thread) | 하나의 프로세스 안에서 동작하는 작업 단위 |
| 멀티스레딩 | 한 프로세스 내에서 여러 스레드를 병렬로 실행 |
| SIMD / MIMD | CPU의 명령 처리 방식 (SIMD는 GPU에서 자주 사용됨) |


> 💡 **SIMD**: Single Instruction, Multiple Data → 하나의 명령으로 여러 데이터 처리  
> 💡 **MIMD**: Multiple Instruction, Multiple Data → 각 코어가 각각 다른 명령 수행


## ✅ 7. 병렬 처리의 한계

### 7.1 병렬화가 어려운 작업 존재
- 어떤 작업은 순서대로 처리해야 함 (예: 로그인 → 결제)

### 7.2 스레드 간 충돌 (Race Condition)
- 두 스레드가 동시에 같은 메모리를 건드리면 오류 발생 가능

### 7.3 병목현상
- 메모리, 캐시, I/O 등의 자원이 병렬 처리 속도를 따라가지 못함

<br>
<br>
<br>

---
# ⚙️ 컴퓨터 구조 – 캐시 일관성과 멀티코어 환경

## ✅ 1. 왜 캐시 일관성이 중요한가?

- 멀티코어 CPU에서는 **각 코어가 독립적인 캐시**를 가진다.  
- 같은 데이터를 서로 다른 캐시에서 읽고 쓰면, **데이터 불일치 문제**가 발생할 수 있다.
- 이걸 해결하기 위한 기술이 바로 **캐시 일관성(Cache Coherency)**이다.

## ✅ 2. 문제 상황 예시

### 시나리오

1. CPU 코어 1: 변수 `x = 10` 이라고 저장한 후, 캐시에 보관
2. CPU 코어 2: 변수 `x = 10`을 읽어 캐시에 보관
3. CPU 코어 1: `x = 20`으로 변경
4. CPU 코어 2: 여전히 `x = 10`이라고 생각함 → ❌ **불일치 발생**

> 데이터는 변경되었는데, 다른 코어는 예전 값을 쓰고 있음 → 문제 발생!

## ✅ 3. 캐시 일관성을 유지하는 방법: MESI 프로토콜

> 💡 CPU는 **캐시 상태를 표시하고**, 이를 통해 **변경된 데이터가 있으면 다른 캐시와 동기화**함.

### MESI 프로토콜 (가장 대표적인 일관성 유지 기법)

| 상태 | 설명 |
|------|------|
| M (Modified) | 캐시에서 변경됨, 메모리와 값 다름 → 유일한 복사본 |
| E (Exclusive) | 읽기만 했고, 다른 캐시에 없음 → 메모리와 같음 |
| S (Shared) | 여러 캐시에 존재함 → 메모리와 동일 |
| I (Invalid) | 무효화된 데이터 → 더 이상 사용 불가 |

> 각 캐시 블록은 이 중 하나의 상태를 가짐

## ✅ 4. 일관성을 맞추는 방식 (캐시 동기화 방법)

### Snoop 기반 프로토콜 (Snooping)
- 모든 캐시가 **버스를 감시**하여 다른 캐시에서 어떤 데이터가 바뀌는지 실시간 체크

> 💡 **Snooping**: “몰래 엿보기”처럼, 다른 캐시에서 발생하는 작업을 감시해서 동기화

### 디렉토리 기반 프로토콜 (Directory-based)
- 중앙 디렉토리(표)가 있어, 어떤 데이터가 어느 캐시에 있는지 추적하고 조정

## ✅ 5. 멀티코어 환경에서 발생하는 문제

### 5.1 캐시 불일치
- 위에서 설명한 일관성 문제

### 5.2 False Sharing
> 서로 다른 변수를 사용하는데, 우연히 **같은 캐시 블록에 있음**  
> → 하나의 쓰기로 인해 **다른 코어 캐시도 무효화됨**

### 5.3 Synchronization Overhead
- 스레드/프로세스 간 데이터를 공유할 때 **락(lock)** 사용 → 성능 감소

## ✅ 6. 성능 최적화를 위한 전략

| 전략 | 설명 |
|------|------|
| 캐시 친화적 데이터 구조 | 연속적인 메모리 구조를 사용 (배열 등) |
| False Sharing 피하기 | 스레드 간 **패딩(padding)** 사용하여 블록 분리 |
| 락 최소화 | 락 대신 atomic 연산, lock-free 구조 사용 |

> 💡 **Atomic 연산**: 중간에 끼어들 수 없는 '한 번에 끝나는' 연산  
> 💡 **Lock-free**: 락을 쓰지 않고 충돌을 회피하는 병렬 처리 방식