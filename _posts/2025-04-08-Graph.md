--- 
title: "ê·¸ë˜í”„ | Graph" 
date: 2025-04-07 11:00:00 +0900
achieved: 2025-04-07 12:00:00 +0900
math: true
categories: [Algorithm, Graph]
tags: [Algorithm, Graph]
---
---------- 	
> ë‚´ê°€ ë³¼ë ¤ê³  ì‘ì„±í•œ ì•Œê³ ë¦¬ì¦˜ ê³µë¶€. 
{: .prompt-info } 


# ğŸ’¾ ê·¸ë˜í”„ (Graph)

## âœ… 1. ê·¸ë˜í”„ë€?

> **ê·¸ë˜í”„(Graph)**ëŠ” ì‚¬ë¬¼(ì •ì , Node) ê°„ì˜ ê´€ê³„(ê°„ì„ , Edge)ë¥¼ í‘œí˜„í•˜ëŠ” ìë£Œêµ¬ì¡°ë‹¤. ì •ì ì€ ì‚¬ëŒ, ë„ì‹œ, ì»´í“¨í„°ì²˜ëŸ¼ **ë¬´ì–¸ê°€ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ë‹¨ìœ„**ì´ê³ , ê°„ì„ ì€ ê·¸ ì •ì  ê°„ì˜ **ì—°ê²° ê´€ê³„**ë¥¼ ì˜ë¯¸í•œë‹¤.

### ğŸ“Œ ê·¸ë˜í”„ ìš©ì–´ ì •ë¦¬

| ìš©ì–´ | ì˜ë¯¸ |
|------|------|
| ì •ì (Vertex) | ë…¸ë“œ(Node), ë°ì´í„° ë‹¨ìœ„ ê°ì²´ |
| ê°„ì„ (Edge) | ë‘ ì •ì ì„ ì—°ê²°í•˜ëŠ” ì„  |
| ì¸ì ‘(Adjacent) | ë‘ ì •ì ì´ ê°„ì„ ìœ¼ë¡œ ì—°ê²°ë¨ |
| ë¬´ë°©í–¥ ê·¸ë˜í”„ | ê°„ì„ ì´ ì–‘ë°©í–¥ (A-Bë©´ B-Aë„ ê°€ëŠ¥) |
| ë°©í–¥ ê·¸ë˜í”„ | ê°„ì„ ì— ë°©í–¥ ìˆìŒ (Aâ†’B) |
| ê°€ì¤‘ì¹˜(Weight) | ê°„ì„ ì— ë¶€ì—¬ëœ ë¹„ìš© ë˜ëŠ” ê±°ë¦¬ |

ê·¸ë˜í”„ëŠ” **ì§€ë„, SNS ì¹œêµ¬ ê´€ê³„, ë„¤íŠ¸ì›Œí¬, ì‘ì—… ìˆœì„œ, ê²Œì„ ë§µ** ë“± ë‹¤ì–‘í•œ ë¶„ì•¼ì—ì„œ í™œìš©ëœë‹¤.

## âœ… 2. ê·¸ë˜í”„ì˜ í‘œí˜„ ë°©ì‹

### 2.1 ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ (Adjacency List)

> ê° ë…¸ë“œê°€ ì—°ê²°ëœ ë…¸ë“œë“¤ì˜ ëª©ë¡ì„ ë¦¬ìŠ¤íŠ¸ë¡œ ì €ì¥í•˜ëŠ” ë°©ì‹. ê°„ì„ ì´ ì ì€ í¬ì†Œ ê·¸ë˜í”„ì— íš¨ìœ¨ì .

```python
n = 5  # ë…¸ë“œ ìˆ˜
graph = [[] for _ in range(n+1)]
graph[1].append(2)
graph[1].append(3)
```

- ê³µê°„ ë³µì¡ë„: O(N + M) (N: ë…¸ë“œ ìˆ˜, M: ê°„ì„  ìˆ˜)
- íŠ¹ì • ê°„ì„  ì¡´ì¬ ì—¬ë¶€ í™•ì¸ì€ ëŠë¦¼

### 2.2 ì¸ì ‘ í–‰ë ¬ (Adjacency Matrix)

> ë…¸ë“œ ê°„ì˜ ì—°ê²° ì—¬ë¶€ë¥¼ 2ì°¨ì› ë°°ì—´ë¡œ ì €ì¥. ëª¨ë“  ê°„ì„  ì •ë³´ë¥¼ ë¹ ë¥´ê²Œ í™•ì¸í•  ìˆ˜ ìˆì§€ë§Œ ê³µê°„ ë‚­ë¹„ê°€ í¼.

```python
n = 5  # ë…¸ë“œ ìˆ˜
graph = [[0] * (n+1) for _ in range(n+1)]
graph[1][2] = 1  # 1ë²ˆ ë…¸ë“œì—ì„œ 2ë²ˆ ë…¸ë“œë¡œ ì—°ê²°ë¨
```

- ê³µê°„ ë³µì¡ë„: O(NÂ²)
- ê°„ì„  í™•ì¸ì€ ë¹ ë¦„ (O(1))

## âœ… 3. ìµœë‹¨ ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜

ê·¸ë˜í”„ì—ì„œ **ìµœë‹¨ ê±°ë¦¬(Shortest Path)** ë¥¼ êµ¬í•˜ëŠ” ëŒ€í‘œì ì¸ ì•Œê³ ë¦¬ì¦˜ë“¤ì„ ì •ë¦¬í•©ë‹ˆë‹¤.  
ìƒí™©ì— ë”°ë¼ ì–´ë–¤ ì•Œê³ ë¦¬ì¦˜ì„ ì¨ì•¼ í•˜ëŠ”ì§€ ë¹ ë¥´ê²Œ íŒë‹¨í•  ìˆ˜ ìˆë„ë¡ êµ¬ì„±í–ˆìŠµë‹ˆë‹¤.


### 1. ë‹¤ìµìŠ¤íŠ¸ë¼ (Dijkstra)

> í•˜ë‚˜ì˜ ì‹œì‘ ì •ì ì—ì„œ **ëª¨ë“  ì •ì ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬**  
> **ëª¨ë“  ê°„ì„  ê°€ì¤‘ì¹˜ â‰¥ 0 (ìŒìˆ˜ ë¶ˆê°€)**

- ì „ëµ: **ê°€ì¥ ê°€ê¹Œìš´ ì •ì ë¶€í„° í™•ì •**
- ìš°ì„ ìˆœìœ„ í (`heapq`)ë¡œ êµ¬í˜„
- ì¤‘ë³µ ë°©ë¬¸ ê°€ëŠ¥í•˜ì§€ë§Œ ë” ì§§ì€ ê²½ë¡œë§Œ ê°±ì‹ í•¨

**ì‹œê°„ ë³µì¡ë„:**  
- ë°°ì—´: O(VÂ²)  
- `heapq` ì‚¬ìš©: **O(E log V)**

**ì‚¬ìš© ì˜ˆì‹œ:**  
```py
import heapq

def dijkstra(start, graph, n):
    INF = int(1e9)
    distance = [INF] * (n + 1)
    distance[start] = 0
    heap = [(0, start)]

    while heap:
        dist, now = heapq.heappop(heap)
        if distance[now] < dist:
            continue
        for neighbor, weight in graph[now]:
            cost = dist + weight
            if cost < distance[neighbor]:
                distance[neighbor] = cost
                heapq.heappush(heap, (cost, neighbor))
    return distance
```

**ì œí•œ ì‚¬í•­:**  
- âŒ **ìŒìˆ˜ ê°„ì„ ì´ í•˜ë‚˜ë¼ë„ ìˆìœ¼ë©´ ë¶€ì •í™•**


### 2. ë²¨ë§Œ-í¬ë“œ (Bellman-Ford)

> í•˜ë‚˜ì˜ ì‹œì‘ ì •ì ì—ì„œ **ëª¨ë“  ì •ì ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬**  
> **ìŒìˆ˜ ê°„ì„  ê°€ëŠ¥**, **ìŒìˆ˜ ì‚¬ì´í´ íƒì§€ ê°€ëŠ¥**

- ì „ëµ: **ëª¨ë“  ê°„ì„ ì„ V-1ë²ˆ ë°˜ë³µí•´ì„œ ì™„í™”**
- Vë²ˆì§¸ ë°˜ë³µì—ì„œ ë˜ ê°±ì‹ ë˜ë©´ â†’ **ìŒìˆ˜ ì‚¬ì´í´ ì¡´ì¬**

**ì‹œê°„ ë³µì¡ë„:**  
- **O(V Ã— E)**

**ì‚¬ìš© ì˜ˆì‹œ:**  
```py
def bellman_ford(start, edges, n):
    INF = int(1e9)
    distance = [INF] * (n + 1)
    distance[start] = 0

    for _ in range(n - 1):
        for u, v, cost in edges:
            if distance[u] + cost < distance[v]:
                distance[v] = distance[u] + cost

    # ìŒìˆ˜ ì‚¬ì´í´ íƒì§€
    for u, v, cost in edges:
        if distance[u] + cost < distance[v]:
            return None  # ìŒìˆ˜ ì‚¬ì´í´ ì¡´ì¬
    return distance
```

**ì¥ì :**  
- ë‹¨ìˆœí•œ êµ¬ì¡°ë¡œ êµ¬í˜„ ì‰¬ì›€  
- ì‚¬ì´í´ ìœ ë¬´ íŒë‹¨ê¹Œì§€ ê°€ëŠ¥

**ë‹¨ì :**  
- ëŠë¦¬ë‹¤


### 3. SPFA (Shortest Path Faster Algorithm)

> ë²¨ë§Œ-í¬ë“œì˜ **ì‹¤ìš©ì  ê°œì„  ì•Œê³ ë¦¬ì¦˜**

- í(Queue) ê¸°ë°˜ìœ¼ë¡œ, **í•„ìš”í•œ ì •ì ë§Œ** ê°±ì‹ 
- ë³´í†µì€ ë§¤ìš° ë¹ ë¥´ì§€ë§Œ, **ìµœì•…ì˜ ê²½ìš°ëŠ” ë²¨ë§Œ-í¬ë“œì™€ ë™ì¼**

**ì‹œê°„ ë³µì¡ë„:**  
- í‰ê· : **O(E)** ìˆ˜ì¤€  
- ìµœì•…: O(V Ã— E)

**ì‚¬ìš© ì˜ˆì‹œ:**  
```py
from collections import deque

def spfa(start, graph, n):
    INF = int(1e9)
    distance = [INF] * (n + 1)
    in_queue = [False] * (n + 1)
    count = [0] * (n + 1)
    
    distance[start] = 0
    queue = deque([start])
    in_queue[start] = True

    while queue:
        now = queue.popleft()
        in_queue[now] = False

        for neighbor, weight in graph[now]:
            if distance[now] + weight < distance[neighbor]:
                distance[neighbor] = distance[now] + weight
                if not in_queue[neighbor]:
                    queue.append(neighbor)
                    in_queue[neighbor] = True
                    count[neighbor] += 1
                    if count[neighbor] >= n:
                        return None  # ìŒìˆ˜ ì‚¬ì´í´ ì¡´ì¬
    return distance
```

**ì¥ì :**  
- ë²¨ë§Œ-í¬ë“œë³´ë‹¤ í›¨ì”¬ ë¹ ë¦„ (ëŒ€ë¶€ë¶„ ìƒí™©ì—ì„œ)


### 4. í”Œë¡œì´ë“œ-ì›Œì…œ (Floyd-Warshall)

> **ëª¨ë“  ì •ì  ìŒ ê°„ì˜ ìµœë‹¨ ê±°ë¦¬**ë¥¼ êµ¬í•¨  
> **2ì°¨ì› ë°°ì—´ + ì í™”ì‹ ê¸°ë°˜**

- ì „ëµ: ì¤‘ê°„ ë…¸ë“œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ê±°ë¦¬ ê°±ì‹ 
- ì¸ì ‘ í–‰ë ¬ ì‚¬ìš©, ê³µê°„ O(VÂ²)

**ì‹œê°„ ë³µì¡ë„:**  
- **O(VÂ³)**

**ì‚¬ìš© ì˜ˆì‹œ:**  
```py
def floyd_warshall(n, edges):
    INF = int(1e9)
    dist = [[INF] * (n + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        dist[i][i] = 0

    for u, v, cost in edges:
        dist[u][v] = cost

    for k in range(1, n + 1):
        for i in range(1, n + 1):
            for j in range(1, n + 1):
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
    
    return dist
```

**ì¥ì :**  
- ê°„ë‹¨í•˜ê³  í™•ì‹¤í•¨
- ëª¨ë“  ìŒ ìµœë‹¨ ê±°ë¦¬ í•œ ë²ˆì— ê³„ì‚°

**ë‹¨ì :**  
- ëŠë¦¼ (Vê°€ ì‘ì„ ë•Œë§Œ ì‚¬ìš© ê°€ëŠ¥)


### 5. Johnsonâ€™s Algorithm

> **ëª¨ë“  ì •ì  ìŒ ê°„ì˜ ìµœë‹¨ ê±°ë¦¬ + ìŒìˆ˜ ê°„ì„  í—ˆìš©**  
> (ë‹¨, **ìŒìˆ˜ ì‚¬ì´í´ì€ ì—†ì–´ì•¼ í•¨**)

- ì „ëµ: ë²¨ë§Œ-í¬ë“œë¡œ ê°€ì¤‘ì¹˜ ë³´ì • â†’ ë‹¤ìµìŠ¤íŠ¸ë¼ ì—¬ëŸ¬ ë²ˆ ìˆ˜í–‰
- í¬ì†Œ ê·¸ë˜í”„ì—ì„œ ìœ ìš©

**ì‹œê°„ ë³µì¡ë„:**  
- **O(VÂ² log V + VE)**

**ì‚¬ìš© ì˜ˆì‹œ:**  
```py
import heapq

def johnsons_algorithm(n, edges):
    INF = int(1e9)
    new_edges = edges + [(0, v, 0) for v in range(1, n + 1)]
    h = [0] * (n + 1)

    # Bellman-Ford to find potential h[v]
    for _ in range(n):
        for u, v, w in new_edges:
            if h[u] + w < h[v]:
                h[v] = h[u] + w

    # Reweight edges
    reweighted = []
    for u, v, w in edges:
        reweighted.append((u, v, w + h[u] - h[v]))

    # Run Dijkstra for each node
    def dijkstra(start):
        dist = [INF] * (n + 1)
        dist[start] = 0
        heap = [(0, start)]
        while heap:
            cost, u = heapq.heappop(heap)
            if cost > dist[u]:
                continue
            for v, w in graph[u]:
                if dist[v] > cost + w:
                    dist[v] = cost + w
                    heapq.heappush(heap, (dist[v], v))
        return dist

    # Build reweighted graph
    graph = [[] for _ in range(n + 1)]
    for u, v, w in reweighted:
        graph[u].append((v, w))

    result = []
    for i in range(1, n + 1):
        dist = dijkstra(i)
        # Reverse weight change
        result.append([d + h[v] - h[i] if d < INF else INF for v, d in enumerate(dist)])

    return result
```

**ì¥ì :**  
- í”Œë¡œì´ë“œ-ì›Œì…œë³´ë‹¤ ë¹ ë¥¼ ìˆ˜ ìˆìŒ (í¬ì†Œ ê·¸ë˜í”„ì—ì„œ)


### ì•Œê³ ë¦¬ì¦˜ ë¹„êµ ìš”ì•½í‘œ

| ì•Œê³ ë¦¬ì¦˜           | ëŒ€ìƒ            | ìŒìˆ˜ ê°„ì„  | ìŒìˆ˜ ì‚¬ì´í´ íƒì§€ | ì‹œê°„ ë³µì¡ë„     | ì£¼ìš” íŠ¹ì§•                             |
|--------------------|------------------|------------|--------------------|------------------|----------------------------------------|
| **ë‹¤ìµìŠ¤íŠ¸ë¼**      | ë‹¨ì¼ ì‹œì‘ì        | âŒ ì•ˆ ë¨     | âŒ ì•ˆ ë¨             | O(E log V)        | ì–‘ìˆ˜ ê°„ì„  ì „ìš©, ë¹ ë¥´ê³  íš¨ìœ¨ì           |
| **ë²¨ë§Œ-í¬ë“œ**       | ë‹¨ì¼ ì‹œì‘ì        | âœ… ê°€ëŠ¥      | âœ… ê°€ëŠ¥              | O(V Ã— E)          | ë‹¨ìˆœ, ìŒìˆ˜ ê°„ì„  ë° ì‚¬ì´í´ ì²˜ë¦¬ ê°€ëŠ¥     |
| **SPFA**           | ë‹¨ì¼ ì‹œì‘ì        | âœ… ê°€ëŠ¥      | âœ… ê°€ëŠ¥              | í‰ê·  O(E), ìµœì•… O(VE) | ë²¨ë§Œ-í¬ë“œë³´ë‹¤ ë¹ ë¦„ (ëŒ€ë¶€ë¶„ ìƒí™©)        |
| **í”Œë¡œì´ë“œ-ì›Œì…œ**   | ëª¨ë“  ì •ì  ìŒ      | âœ… ê°€ëŠ¥      | âŒ (ì§ì ‘ íƒì§€ X)     | O(VÂ³)             | ëª¨ë“  ê±°ë¦¬ í•œ ë²ˆì—, ëŠë¦¼                 |
| **Johnson**        | ëª¨ë“  ì •ì  ìŒ      | âœ… ê°€ëŠ¥      | âŒ (ì¡´ì¬í•˜ë©´ ì‹¤íŒ¨)   | O(VÂ² log V + VE)  | í¬ì†Œ ê·¸ë˜í”„ì—ì„œ ìœ ë¦¬, ë‹¤ìµìŠ¤íŠ¸ë¼ + ë³´ì • |


### ì–´ë–¤ ê±¸ ì¨ì•¼ í• ê¹Œ?

| ìƒí™©                                 | ì¶”ì²œ ì•Œê³ ë¦¬ì¦˜    |
|--------------------------------------|-------------------|
| ì‹œì‘ì  í•˜ë‚˜, ì–‘ìˆ˜ ê°„ì„ ë§Œ            | **ë‹¤ìµìŠ¤íŠ¸ë¼**     |
| ì‹œì‘ì  í•˜ë‚˜, ìŒìˆ˜ ê°„ì„  ìˆìŒ         | **ë²¨ë§Œ-í¬ë“œ** or **SPFA** |
| ëª¨ë“  ì •ì  ìŒ, ì •ì  ìˆ˜ ì‘ìŒ (â‰¤ 100)  | **í”Œë¡œì´ë“œ-ì›Œì…œ**  |
| ëª¨ë“  ì •ì  ìŒ, ì •ì  ìˆ˜ í¬ê³  í¬ì†Œ ê·¸ë˜í”„ | **Johnson's**     |
| ìŒìˆ˜ ì‚¬ì´í´ ì¡´ì¬ ì—¬ë¶€ íŒë‹¨ì´ í•„ìš”í•¨ | **ë²¨ë§Œ-í¬ë“œ** or **SPFA** |


## âœ… 4. ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ (MST)

ê·¸ë˜í”„ì—ì„œ **ëª¨ë“  ì •ì ì„ ì—°ê²°í•˜ë©´ì„œ ì „ì²´ ê°€ì¤‘ì¹˜ì˜ í•©ì´ ìµœì†Œê°€ ë˜ëŠ” íŠ¸ë¦¬**ë¥¼ ì°¾ëŠ” ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤.  
ì‚¬ì´í´ì´ ì—†ê³ , ê°„ì„ ì˜ ìˆ˜ê°€ **ì •ì  ìˆ˜ - 1ê°œ**ì¸ íŠ¸ë¦¬ë¥¼ êµ¬ì„±í•©ë‹ˆë‹¤.

### 1. í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ (Kruskal's Algorithm)

> ê°„ì„ ì„ ê°€ì¤‘ì¹˜ ìˆœìœ¼ë¡œ ì •ë ¬í•˜ê³ , **ì‚¬ì´í´ì´ ìƒê¸°ì§€ ì•Šë„ë¡** í•˜ë‚˜ì”© ì„ íƒí•´ ì—°ê²°  
> **Union-Find(Disjoint Set)** ìë£Œêµ¬ì¡° í™œìš©

- ì „ëµ: **ê°€ì¤‘ì¹˜ê°€ ê°€ì¥ ì‘ì€ ê°„ì„ ë¶€í„° ì„ íƒ**
- ê°„ì„ ì„ ì •ë ¬í•œ í›„ ì‚¬ì´í´ì´ ìƒê¸°ì§€ ì•Šë„ë¡ ì—°ê²°
- ê°„ì„  ì¤‘ì‹¬ ë°©ì‹

**ì‹œê°„ ë³µì¡ë„:**  
- O(E log E) (ê°„ì„  ì •ë ¬ ë¹„ìš©)

**ì‚¬ìš© ì˜ˆì‹œ:**
```py
def kruskal(n, edges):
    parent = [i for i in range(n + 1)]

    def find(x):
        if parent[x] != x:
            parent[x] = find(parent[x])
        return parent[x]

    def union(a, b):
        a = find(a)
        b = find(b)
        if a != b:
            parent[b] = a
            return True
        return False

    edges.sort(key=lambda x: x[2])  # ê°€ì¤‘ì¹˜ ê¸°ì¤€ ì •ë ¬
    total = 0
    for u, v, weight in edges:
        if union(u, v):
            total += weight
    return total
```

**ì¥ì :**  
- êµ¬í˜„ ê°„ë‹¨, **ê°„ì„  ìˆ˜ê°€ ë§ì„ ë•Œ ìœ ë¦¬**

**ë‹¨ì :**  
- ì •ì  ì—°ê²° ìƒíƒœë¥¼ í™•ì¸í•˜ê¸° ìœ„í•´ **ìœ ë‹ˆì˜¨-íŒŒì¸ë“œ êµ¬í˜„ í•„ìš”**

### 2. í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ (Prim's Algorithm)

> ì •ì  í•˜ë‚˜ì—ì„œ ì‹œì‘í•´, **ì—°ê²°ëœ ì •ì  ì¤‘ ê°€ì¥ ê°€ì¤‘ì¹˜ê°€ ë‚®ì€ ê°„ì„ ì„ ì„ íƒ**  
> **ìš°ì„ ìˆœìœ„ í(heapq)**ë¡œ êµ¬í˜„

- ì „ëµ: **íŠ¸ë¦¬ì— ì—°ê²° ê°€ëŠ¥í•œ ê°€ì¥ ì§§ì€ ê°„ì„  ì„ íƒ**
- ë°©ë¬¸í•œ ì •ì ì—ì„œ í™•ì¥í•˜ëŠ” ë°©ì‹
- ì •ì  ì¤‘ì‹¬ ë°©ì‹

**ì‹œê°„ ë³µì¡ë„:**  
- O(E log V) (`heapq` ì‚¬ìš© ì‹œ)

**ì‚¬ìš© ì˜ˆì‹œ:**
```py
import heapq

def prim(start, graph, n):
    visited = [False] * (n + 1)
    heap = [(0, start)]
    total = 0

    while heap:
        weight, u = heapq.heappop(heap)
        if visited[u]:
            continue
        visited[u] = True
        total += weight
        for v, w in graph[u]:
            if not visited[v]:
                heapq.heappush(heap, (w, v))
    return total
```

**ì¥ì :**  
- êµ¬í˜„ì´ ì§ê´€ì , **ì •ì  ìˆ˜ê°€ ì ê³  ê°„ì„ ì´ ë§ì„ ë•Œ ìœ ë¦¬**

**ë‹¨ì :**  
- ê°„ì„ ì´ í¬ì†Œí•œ ê·¸ë˜í”„ì—ì„œëŠ” ë‹¤ì†Œ ëŠë¦´ ìˆ˜ ìˆìŒ


### MST ì•Œê³ ë¦¬ì¦˜ ë¹„êµ ìš”ì•½í‘œ

| ì•Œê³ ë¦¬ì¦˜      | ë°©ì‹        | ìë£Œêµ¬ì¡°        | ì‹œê°„ ë³µì¡ë„     | íŠ¹ì§•                          |
|---------------|-------------|------------------|------------------|-------------------------------|
| **í¬ë£¨ìŠ¤ì¹¼**   | ê°„ì„  ì¤‘ì‹¬    | ìœ ë‹ˆì˜¨-íŒŒì¸ë“œ    | O(E log E)        | ê°„ì„  ìœ„ì£¼, ì •ë ¬ í•„ìš”           |
| **í”„ë¦¼**       | ì •ì  ì¤‘ì‹¬    | ìš°ì„ ìˆœìœ„ í (`heapq`) | O(E log V)        | ì •ì  í™•ì¥ ë°©ì‹, ì‹œì‘ì  í•„ìš”     |


### ì–´ë–¤ ê±¸ ì¨ì•¼ í• ê¹Œ?

| ìƒí™©                                 | ì¶”ì²œ ì•Œê³ ë¦¬ì¦˜    |
|--------------------------------------|-------------------|
| ê°„ì„ ì´ ë§ê³  ì •ì  ìˆ˜ê°€ ì‘ìŒ          | **í¬ë£¨ìŠ¤ì¹¼**       |
| ì •ì  ìˆ˜ê°€ ë§ê³  ê°„ì„ ì´ í¬ì†Œí•˜ì§€ ì•ŠìŒ | **í”„ë¦¼**           |
| ëª¨ë“  ì •ì ì„ ë°˜ë“œì‹œ ì—°ê²°í•´ì•¼ í•¨      | ë‘˜ ë‹¤ ê°€ëŠ¥ (MST ë¬¸ì œì„) |


## âœ… 5. ê·¸ë˜í”„ ì—°ìŠµ ë¬¸ì œ ì¶”ì²œ

| ë‚œì´ë„ | ë¬¸ì œ ë§í¬ |
|--------|------------|
| â­â­ | [ë°±ì¤€ 1753 - ìµœë‹¨ê²½ë¡œ (ë‹¤ìµìŠ¤íŠ¸ë¼)](https://www.acmicpc.net/problem/1753) |
| â­â­â­ | [ë°±ì¤€ 1865 - ì›œí™€ (ë²¨ë§Œí¬ë“œ)](https://www.acmicpc.net/problem/1865) |
| â­â­â­â­ | [ë°±ì¤€ 1197 - ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ (í¬ë£¨ìŠ¤ì¹¼)](https://www.acmicpc.net/problem/1197) |
| â­â­â­â­ | [ë°±ì¤€ 11404 - í”Œë¡œì´ë“œ](https://www.acmicpc.net/problem/11404) |

## âœ… 6. ë¬¸ì œ í’€ì´

- ë°±ì¤€ 1753 - ìµœë‹¨ê²½ë¡œ (ë‹¤ìµìŠ¤íŠ¸ë¼)

```py
import sys
import heapq
input = sys.stdin.readline

v,e = map(int,input().split())
k = int(input())
g = {i+1:[] for i in range(v)}
for _ in range(e):
    a,b,w = map(int,input().split())
    g[a].append((b,w))
def dijkstra(s):
    d = [float('inf')] * (v+1)
    d[s] = 0
    heap = [(0,s)]
    while heap:
        dist,now =heapq.heappop(heap)
        if d[now] < dist:
            continue
        for b,w in g[now]:
            cost = dist + w
            if cost < d[b]:
                d[b] = cost
                heapq.heappush(heap,(cost,b))
    return d

d = dijkstra(k)
for i in d[1:]:
    print(i if i != float('inf') else 'INF')
```

> **heapq**
> - Python ë‚´ì¥ ìš°ì„ ìˆœìœ„ í (ìµœì†Œ í™)
> - í•­ìƒ ê°€ì¥ ì‘ì€ ê°’ì´ ë¨¼ì € ë‚˜ì˜´
> - `push`, `pop` â†’ O(log N)
> ```python
> import heapq
> heap = []
> heapq.heappush(heap, value)   # ê°’ ì¶”ê°€
> heapq.heappop(heap)           # ê°€ì¥ ì‘ì€ ê°’ êº¼ë‚´ê¸°
> heapq.heapify(list)           # ë¦¬ìŠ¤íŠ¸ë¥¼ í™ êµ¬ì¡°ë¡œ ë³€í™˜
> ```
> ë‹¤ìµìŠ¤íŠ¸ë¼ì—ì„œ ì™œ heapqë¥¼ ì“¸ê¹Œ?
> - ë‹¤ìµìŠ¤íŠ¸ë¼ëŠ” **ê°€ì¥ ê°€ê¹Œìš´ ì •ì **ì„ ë°˜ë³µì ìœ¼ë¡œ ì°¾ì•„ì•¼ í•¨
> - `heapq`ë¥¼ ì‚¬ìš©í•˜ë©´ â†’ ìµœì†Œ ê±°ë¦¬ ì •ì ì„ **ë¹ ë¥´ê²Œ êº¼ë‚¼ ìˆ˜ ìˆìŒ**
> - ì‹œê°„ë³µì¡ë„ ê°œì„ : O(VÂ²) â†’ O(E log V)



- ë°±ì¤€ 1865 - ì›œí™€ (ë²¨ë§Œí¬ë“œ)

```py
import sys
input = sys.stdin.readline

def bellman_ford(n,g):
    d = [0] * (n+1)
    
    for i in range(1,n):
        for u,v,w in g:
            if d[v] > d[u]+w:
                d[v] = d[u] +w
    for u,v,w in g:
        if d[v] > d[u]+w:
            return 'YES'
    return 'NO'

tc = int(input())
for _ in range(tc):
    n,m,w=map(int,input().split())
    g = []
    for _ in range(m):
        s,e,t = map(int,input().split())
        g.append((s,e,t))
        g.append((e,s,t))
    for _ in range(w):
        s,e,t = map(int,input().split())
        g.append((s,e,-t))
    print(bellman_ford(n,g))
```

- ë°±ì¤€ 1197 - ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ (í¬ë£¨ìŠ¤ì¹¼)

```py
import sys
input = sys.stdin.readline
sys.setrecursionlimit(10**6)
v,e = map(int,input().split())

p = [i for i in range(v+1)]
g = [list(map(int,input().split())) for _ in range(e)]
def find(x):
    if p[x] != x:
        p[x] = find(p[x])
    return p[x]

def union(a,b):
    a = find(a)
    b = find(b)
    if a!=b:
        p[b] = a
        return True
    return False
cnt = 0
g.sort(key = lambda x : x[2])
for u, v, w in g:
    if union(u,v):
        cnt+=w
print(cnt)
```

- ë°±ì¤€ 11404 - í”Œë¡œì´ë“œ

```py
import sys
import heapq

input = sys.stdin.readline

n = int(input())
m = int(input())
answer = []
g = {i + 1: [] for i in range(n)}

for _ in range(m):
    a, b, c = map(int, input().split())
    found = False
    for idx, (nb, nc) in enumerate(g[a]):
        if nb == b:
            if c < nc:
                g[a][idx] = (b, c)
            found = True
            break
    if not found:
        g[a].append((b, c))

for i in range(1, n + 1):
    cost = [float('inf')] * (n + 1)
    heap = [(0, i)]
    cost[i] = 0

    while heap:
        now_cost, now = heapq.heappop(heap)
        if cost[now] < now_cost:
            continue
        for next_, c in g[now]:
            sum_ = now_cost + c
            if sum_ < cost[next_]:
                cost[next_] = sum_
                heapq.heappush(heap, (sum_, next_))

    for j in range(1, n + 1):
        if cost[j] == float('inf'):
            cost[j] = 0

    answer.append(cost)

for r in answer:
    print(' '.join(map(str, r[1:])))
```

> ì´ìŠˆ 1: 
> - **ì›ì¸**: ì¤‘ë³µëœ ë…¸ë“œ ì¤‘ ë‚®ì€ ê°’ë§Œ appendí•˜ê¸°
> - **í•´ê²°** 
>```py
> for _ in range(m):
>    a, b, c = map(int, input().split())
>    found = False
>    for idx, (nb, nc) in enumerate(g[a]):
>        if nb == b:
>            if c < nc:
>                g[a][idx] = (b, c)
>            found = True
>            break
>    if not found:
>        g[a].append((b, c))
> ```

